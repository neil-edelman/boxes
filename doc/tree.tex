\documentclass[12pt]{article}

% input
\bibliographystyle{ieeetr}
\usepackage[utf8]{inputenc}
%\usepackage{times} % font
\usepackage{lmodern} % scalable font
\usepackage[pdftex]{graphicx} % include graphics
\usepackage{amsmath} % align, nobreakdash
\usepackage[pdf,tmpdir]{graphviz} % digraph
\usepackage{fullpage} % book margins -> std margins
\usepackage{wrapfig} % wrapfigure
%\usepackage{moreverb} % verbatimtabinput
\usepackage{subcaption} % subcaptionbox
\usepackage[colorlinks]{hyperref} % pdf links
\usepackage{url} % url support
%\usepackage{comment} % comment
\usepackage{xfrac}
\usepackage[table]{xcolor}

\usepackage{siunitx}
%\usepackage{graphicx} already
\usepackage{latexsym}
\usepackage{keyval}
\usepackage{ifthen}
\usepackage{moreverb}
\usepackage[siunitx, subfolder]{gnuplottex}

% https://tex.stackexchange.com/questions/259247/rescaling-gnuplottex-to-fit-in-subfigure
%\usepackage{epstopdf}
%\usepackage{printlen}
%\usepackage[utf8]{inputenx}
%\usepackage{xparse}
%\ExplSyntaxOn
%\DeclareExpandableDocumentCommand{\convertlen}{ O{cm} m }
% {
%  \dim_to_unit:nn { #2 } { 1 #1 } cm
% }
%\ExplSyntaxOff
% fuck it, just guess

\newcommand{\code}[1]{\colorbox{light-gray}{\texttt{#1}}}
\def\Scale{0.5}

% colourize titles
\definecolor{light-gray}{gray}{0.95}
\definecolor{ilrblue}{RGB}{79,166,220}
\usepackage{titling}
\pretitle{\vspace{-3em}\fontfamily{\sfdefault}\fontsize{18bp}{18bp}\color{ilrblue}\selectfont}
\posttitle{\par\vspace{18bp}}
\preauthor{\normalfont\bfseries\selectfont\MakeUppercase}
\postauthor{\par\vspace{4bp}}
\predate{\normalfont\selectfont}
\postdate{\par\vspace{-8bp}}
\usepackage{titlesec}
\titleformat{\section}{\fontfamily{\sfdefault}\selectfont\normalsize\bfseries\color{ilrblue}\MakeUppercase}{\thesection}{1em}{}
\titleformat{\subsection}{\fontfamily{\sfdefault}\normalsize\bfseries\color{ilrblue}}{\thesubsection}{1em}{}
\titleformat{\subsubsection}{\fontfamily{\sfdefault}\normalsize\bfseries\color{ilrblue}\it}{\thesubsubsection}{1em}{}
\makeatletter
\renewenvironment{abstract}{%
    \if@twocolumn
      \section*{\abstractname}%
    \else \small %
      \begin{center}%
        {\bfseries\color{ilrblue} \abstractname\vspace{\z@}\vspace{-6bp}}%
      \end{center}%
      \quotation
    \fi}
    {\if@twocolumn\else\endquotation\fi}
\makeatother

% for hyperref
\hypersetup{
  linkcolor=ilrblue, % internal (figure) links
  urlcolor=ilrblue,
  filecolor=ilrblue,
  citecolor=ilrblue, % bibliography links
  pdfauthor={\@author},
  pdftitle={\@title},
  pdfsubject={\@title},
  pdfpagemode=UseNone
}

\author{Neil A. Edelman}
\title{B-tree design}
\date{2022-08-05}

\begin{document}

\maketitle

\abstract{Several design decisions for a B-tree are discussed.}

\section{Design}

A tree is used as an ordered set or map. For memory locality, this is implemented B-tree\cite{bayer1972organization}. In an implementation for C, we would expect memory usage to be low, performance to be high, and simplicity over complexity. Practically, this means that B$^+$-trees and B$^*$-trees are less attractive, along with an added layer of order statistic tree. The nodes are linked one-way and iteration is very simple. This precludes multi-maps. The use-case has no concurrency and places importance on modification.

\subsection{Branching factor}

The branching factor, or order as \cite{knuth1997sorting}, is a fixed value between $[3,\text{UCHAR\_MAX}+1]$. The implementation has no buffering or middle-memory management. Thus, a high-order means greater memory allocation granularity, leading to asymptotically desirable trees. Small values produce much more compact trees. Four produces an isomorphism with red-black trees.

\subsection{Maximum and minimum keys}

We use fixed-length nodes. In \cite{goodrich2011data}, these are $(a,b)$-trees as $(\text{minimum}+1, \text{maxumum}+1)$\nobreakdash-trees. That is, the maximum is the node's key capacity. maximum+1 is also the order, since the keys can be thought of as an implicit complete binary tree. We differentiate by branch and leaf; a leaf node has no need for null-children, so we don't include them.

Performance will be
$\mathcal{O}(\log_{\text{minimum}+1} \text{size})$. Usually this is $\text{minimum} = \lceil (\text{maximum}+1)/2\rceil-1$. However,
 smaller values are less-eager, providing another layer of hysteresis. This is especially good for smaller trees. \cite{johnson1993b} shows good results with freeing at empty, but in this the worst-case is all the nodes contain one key.
For our purposes, a compromise of $\lceil(\text{maximum}+1)/3\rceil-1$ is proposed. In a sense, it is the opposite of a B$^*$-tree\cite{knuth1997sorting, douglas1979ubiquitous}, where $\frac{1}{3}$ instead of $\frac{2}{3}$ of the capacity is full. This reduces asymptotic performance, but increases laziness and modification efficiency.

\subsection{Bulk add}

In this tree implementation, bulk loading is ordered addition such that the key is always the maximum in the tree so far. This will quickly produce a more compact tree initially. If the keys are in order, compare adding them normally, which results one-half occupancy.

Bulk-add will add the key to the maximum side at the lowest level where there is space, ignoring the rules for splitting. If this is a non-leaf, additional nodes with no-keys and one child are recruited. If there is no space at all on the maximum side, another level is made. Because the B-tree rules may be violated, the final tree where bulk-addition has occurred should finalize the maximum side of the tree, balancing and restoring the B-tree invariants.

\begin{figure}%
\centering%
\digraph[scale=\Scale]{bulk}{
	graph [rankdir=LR, truecolor=true, bgcolor=transparent, fontname="Bitstream Vera Sans", splines=false];
	node [shape=none, fontname="Bitstream Vera Sans"];
	edge [fontname="Bitstream Vera Sans", style=dashed];
	trunk0x100606ca0 [label = <
<table border="1" cellspacing="0" bgcolor="Grey95">
	<tr><td border="0" port="0"><font color="Gray75">Ologshar</font></td></tr>
	<tr><td border="0" align="left" port="1" bgcolor="Gray90">38</td></tr>
	<tr><td border="0" align="left" port="2">60</td></tr>
</table>>];
	trunk0x100606ca0:0:se -> trunk0x100709020;
	trunk0x100606ca0:1:se -> trunk0x10060d650;
	trunk0x100606ca0:2:se -> trunk0x100606cd0;
	trunk0x100709020 [label = <
<table border="1" cellspacing="0" bgcolor="Grey95">
	<tr><td border="0" port="0"><font color="Gray75">Ronkaron</font></td></tr>
	<tr><td border="0" align="left" port="1" bgcolor="Gray90">4</td></tr>
	<tr><td border="0" align="left" port="2">8</td></tr>
</table>>];
	trunk0x10060d650 [label = <
<table border="1" cellspacing="0" bgcolor="Grey95">
	<tr><td border="0" port="0"><font color="Gray75">Overil</font></td></tr>
	<tr><td border="0" align="left" port="1" bgcolor="Gray90">43</td></tr>
	<tr><td border="0" align="left" port="2">48</td></tr>
</table>>];
	trunk0x100606cd0 [label = <
<table border="1" cellspacing="0" bgcolor="Grey95">
	<tr><td border="0" port="0"><font color="Gray75">Ickkhalok</font></td></tr>
</table>>];
}
\caption{An order-3 sample that is undergoing bulk-addition. The adds must be in order. The minimum invariant for \code{Ickkhalok} is violated, since it has no keys. The finalize method would balance the keys with \code{Overil}.}%
\label{bulk}%
\end{figure}%

\subsection{Adding a key}

\subsection{Deleting a key}

\section{Example Comparison}

%\begin{wrapfigure}{r}{0.5\textwidth} %[!ht]
\begin{figure}
	\centering
	\subcaptionbox{Separate-chaining.\label{types:separate}}{%
		\digraph[scale=\Scale]{separate}{
	rankdir=LR;
	graph [truecolor=true, bgcolor=transparent];
	fontface=modern;
	node [shape=box, style=filled, fillcolor="Gray95"];
	hash [label=<<TABLE BORDER="0">
	<TR>
		<TD BORDER="0"><FONT FACE="Times-Italic">i</FONT></TD>
		<TD BORDER="0"><FONT FACE="Times-Bold">next</FONT></TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x0</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT">0x1</TD>
		<TD PORT="1">\detokenize{⬤}</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x2</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT">0x3</TD>
		<TD PORT="3">\detokenize{⬤}</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x4</TD>
		<TD PORT="4" BGCOLOR="Gray90">\detokenize{⬤}</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT">0x5</TD>
		<TD PORT="5">\detokenize{⬤}</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x6</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT">0x7</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x8</TD>
		<TD PORT="8" BGCOLOR="Gray90">\detokenize{⬤}</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT">0x9</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0xa</TD>
		<TD PORT="10" BGCOLOR="Gray90">\detokenize{⬤}</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BORDER="0">0xb</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0xc</TD>
		<TD PORT="12" BGCOLOR="Gray90">\detokenize{⬤}</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT">0xd</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0xe</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT">0xf</TD>
		<TD PORT="15">\detokenize{⬤}</TD>
	</TR>
</TABLE>>];
	e1 [label=<<TABLE BORDER="0">
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x91</TD>
		<TD ALIGN="LEFT">Castor</TD>
		<TD ALIGN="RIGHT">52</TD>
		<TD PORT="1">\detokenize{⬤}</TD>
	</TR>
</TABLE>>];
	e3 [label=<<TABLE BORDER="0">
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x3</TD>
		<TD ALIGN="LEFT">Deneb</TD>
		<TD ALIGN="RIGHT">2615</TD>
		<TD PORT="3">\detokenize{⬤}</TD>
	</TR>
</TABLE>>];
	e4 [label=<<TABLE BORDER="0">
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x44</TD>
		<TD ALIGN="LEFT">Sirius</TD>
		<TD ALIGN="RIGHT">8.6</TD>
		<TD PORT="4">\detokenize{⬤}</TD>
	</TR>
</TABLE>>];
	e5 [label=<<TABLE BORDER="0">
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x35</TD>
		<TD ALIGN="LEFT">Spica</TD>
		<TD ALIGN="RIGHT">250</TD>
		<TD PORT="5">\detokenize{⬤}</TD>
	</TR>
</TABLE>>];
	e8 [label=<<TABLE BORDER="0">
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0xd8</TD>
		<TD ALIGN="LEFT">Rigel</TD>
		<TD ALIGN="RIGHT">860</TD>
		<TD PORT="8">\detokenize{⬤}</TD>
	</TR>
</TABLE>>];
	e10 [label=<<TABLE BORDER="0">
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x4a</TD>
		<TD ALIGN="LEFT">Betelgeuse</TD>
		<TD ALIGN="RIGHT">700</TD>
		<TD PORT="10">\detokenize{⬤}</TD>
	</TR>
</TABLE>>];
	e11 [label=<<TABLE BORDER="0">
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x4f</TD>
		<TD ALIGN="LEFT">Procyon</TD>
		<TD ALIGN="RIGHT">11</TD>
		<TD PORT="11">\detokenize{◯}</TD>
	</TR>
</TABLE>>];
	e12 [label=<<TABLE BORDER="0">
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0xec</TD>
		<TD ALIGN="LEFT">Regulus</TD>
		<TD ALIGN="RIGHT">79</TD>
		<TD PORT="12">\detokenize{⬤}</TD>
	</TR>
</TABLE>>];
	e13 [label=<<TABLE BORDER="0">
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x33</TD>
		<TD ALIGN="LEFT">Antares</TD>
		<TD ALIGN="RIGHT">550</TD>
		<TD PORT="13">\detokenize{◯}</TD>
	</TR>
</TABLE>>];
	e14 [label=<<TABLE BORDER="0">
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0xb3</TD>
		<TD ALIGN="LEFT">Sol</TD>
		<TD ALIGN="RIGHT">0</TD>
		<TD PORT="14">\detokenize{◯}</TD>
	</TR>
</TABLE>>];
	e15 [label=<<TABLE BORDER="0">
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x9f</TD>
		<TD ALIGN="LEFT">Polaris</TD>
		<TD ALIGN="RIGHT">430</TD>
		<TD PORT="15">\detokenize{⬤}</TD>
	</TR>
</TABLE>>];
	node [shape=plain, fillcolor=none, headclip = false, tailclip=false]
	hash:1 -> e1;
	hash:3 -> e3 -> e13 -> e14;
	hash:4 -> e4;
	hash:5 -> e5;
	hash:8 -> e8;
	hash:10 -> e10;
	hash:12 -> e12;
	hash:15 -> e15;
	e15 -> e11;
		}
	}
	\subcaptionbox{Open-addressing.\label{types:open}}{%
		\digraph[scale=\Scale]{open}{
	rankdir=LR;
	graph [truecolor=true, bgcolor=transparent];
	fontface=modern;
	node [shape=box, style=filled, fillcolor="Gray95"];
	hash [label=<<TABLE BORDER="0">
	<TR>
		<TD BORDER="0"><FONT FACE="Times-Italic">i</FONT></TD>
		<TD BORDER="0"><FONT FACE="Times-Italic">disp.</FONT></TD>
		<TD BORDER="0"><FONT FACE="Times-Bold">hash</FONT></TD>
		<TD BORDER="0"><FONT FACE="Times-Bold">key</FONT></TD>
		<TD BORDER="0"><FONT FACE="Times-Bold">value</FONT></TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x0</TD>
		<TD BGCOLOR="Gray90">1</TD>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x4f</TD>
		<TD ALIGN="LEFT" BGCOLOR="Gray90">Procyon</TD>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">11</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT">0x1</TD>
		<TD>0</TD>
		<TD ALIGN="RIGHT">0x91</TD>
		<TD ALIGN="LEFT">Castor</TD>
		<TD ALIGN="RIGHT">52</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x2</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT">0x3</TD>
		<TD>0</TD>
		<TD ALIGN="RIGHT">0x3</TD>
		<TD ALIGN="LEFT">Deneb</TD>
		<TD ALIGN="RIGHT">2615</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x4</TD>
		<TD BGCOLOR="Gray90">1</TD>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x33</TD>
		<TD ALIGN="LEFT" BGCOLOR="Gray90">Antares</TD>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">550</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT">0x5</TD>
		<TD PORT="14">2</TD>
		<TD ALIGN="RIGHT">0xb3</TD>
		<TD ALIGN="LEFT">Sol</TD>
		<TD ALIGN="RIGHT">0</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x6</TD>
		<TD BGCOLOR="Gray90">2</TD>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x44</TD>
		<TD ALIGN="LEFT" BGCOLOR="Gray90">Sirius</TD>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">8.6</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT">0x7</TD>
		<TD>2</TD>
		<TD ALIGN="RIGHT">0x35</TD>
		<TD ALIGN="LEFT">Spica</TD>
		<TD ALIGN="RIGHT">250</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x8</TD>
		<TD PORT="8" BGCOLOR="Gray90">0</TD>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0xd8</TD>
		<TD ALIGN="LEFT" BGCOLOR="Gray90">Rigel</TD>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">860</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT">0x9</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0xa</TD>
		<TD PORT="10" BGCOLOR="Gray90">0</TD>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x4a</TD>
		<TD ALIGN="LEFT" BGCOLOR="Gray90">Betelgeuse</TD>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">700</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT">0xb</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0xc</TD>
		<TD PORT="12" BGCOLOR="Gray90">0</TD>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0xec</TD>
		<TD ALIGN="LEFT" BGCOLOR="Gray90">Regulus</TD>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">79</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT">0xd</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0xe</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT">0xf</TD>
		<TD PORT="15">0</TD>
		<TD ALIGN="RIGHT">0x9f</TD>
		<TD ALIGN="LEFT">Polaris</TD>
		<TD ALIGN="RIGHT">430</TD>
	</TR>
</TABLE>>];
	node [shape=plain, fillcolor=none]
		}
	}
	\subcaptionbox{Inline-chaining.\label{types:inline}}{%
		\digraph[scale=\Scale]{inline}{
	rankdir=LR;
	graph [truecolor=true, bgcolor=transparent];
	fontface=modern;
	node [shape=box, style=filled, fillcolor="Gray95"];
	hash [label=<<TABLE BORDER="0">
	<TR>
		<TD BORDER="0"><FONT FACE="Times-Italic">i</FONT></TD>
		<TD BORDER="0"><FONT FACE="Times-Bold">hash</FONT></TD>
		<TD BORDER="0"><FONT FACE="Times-Bold">key</FONT></TD>
		<TD BORDER="0"><FONT FACE="Times-Bold">value</FONT></TD>
		<TD BORDER="0"><FONT FACE="Times-Bold">next</FONT></TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x0</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT">0x1</TD>
		<TD ALIGN="RIGHT">0x91</TD>
		<TD ALIGN="LEFT">Castor</TD>
		<TD ALIGN="RIGHT">52</TD>
		<TD PORT="1">\detokenize{⬤}</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x2</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT">0x3</TD>
		<TD ALIGN="RIGHT">0x3</TD>
		<TD ALIGN="LEFT">Deneb</TD>
		<TD ALIGN="RIGHT">2615</TD>
		<TD PORT="3">\detokenize{⬤}</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x4</TD>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x44</TD>
		<TD ALIGN="LEFT" BGCOLOR="Gray90">Sirius</TD>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">8.6</TD>
		<TD PORT="4" BGCOLOR="Gray90">\detokenize{⬤}</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT">0x5</TD>
		<TD ALIGN="RIGHT">0x35</TD>
		<TD ALIGN="LEFT">Spica</TD>
		<TD ALIGN="RIGHT">250</TD>
		<TD PORT="5">\detokenize{⬤}</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x6</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT">0x7</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x8</TD>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0xd8</TD>
		<TD ALIGN="LEFT" BGCOLOR="Gray90">Rigel</TD>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">860</TD>
		<TD PORT="8" BGCOLOR="Gray90">\detokenize{⬤}</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT">0x9</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0xa</TD>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x4a</TD>
		<TD ALIGN="LEFT" BGCOLOR="Gray90">Betelgeuse</TD>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">700</TD>
		<TD PORT="10" BGCOLOR="Gray90">\detokenize{⬤}</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BORDER="2">0xb</TD>
		<TD ALIGN="RIGHT">0x4f</TD>
		<TD ALIGN="LEFT">Procyon</TD>
		<TD ALIGN="RIGHT">11</TD>
		<TD PORT="11">\detokenize{◯}</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0xc</TD>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0xec</TD>
		<TD ALIGN="LEFT" BGCOLOR="Gray90">Regulus</TD>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">79</TD>
		<TD PORT="12" BGCOLOR="Gray90">\detokenize{⬤}</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT">0xd</TD>
		<TD ALIGN="RIGHT">0x33</TD>
		<TD ALIGN="LEFT">Antares</TD>
		<TD ALIGN="RIGHT">550</TD>
		<TD PORT="13">\detokenize{◯}</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0xe</TD>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0xb3</TD>
		<TD ALIGN="LEFT" BGCOLOR="Gray90">Sol</TD>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0</TD>
		<TD PORT="14" BGCOLOR="Gray90">\detokenize{◯}</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT">0xf</TD>
		<TD ALIGN="RIGHT">0x9f</TD>
		<TD ALIGN="LEFT">Polaris</TD>
		<TD ALIGN="RIGHT">430</TD>
		<TD PORT="15">\detokenize{⬤}</TD>
	</TR>
</TABLE>>];
	node [shape=plain, fillcolor=none]
	e13 [label="0xd"];
	hash:3 -> e13 [tailclip=false];
	e14 [label="0xe"];
	e13 -> e14;
	i0xe [label="0xe", fontcolor="Gray"];
	hash:13 -> i0xe [color="Gray"];
	e11 [label="0xb"];
	hash:15 -> e11 [tailclip=false];
		}
	}
	\caption{A map from some star names to light-year distance using different collision-resolution schemes. Load factor \sfrac{11}{16} = 0.69. Expected value: chained number of queries, 1.4(7);
%1.36(0.7),
open probe-length, 1.6(9),
%1.60(0.9), (sample
(standard deviation.)\label{types}
Order of insertion: Sol, Sirius, Rigel, Procyon, Betelgeuse, Antares, Spica, Deneb, Regulus, Castor, Polaris.}
\end{figure}

Figure~\ref{types} shows a comparison of some standard hash-table types. It uses D.J.~Bernstein's {\it djb2} to hash a string to 8-bit unsigned integer. All tables use a most-recently-used heuristic as probe-order; experimentally, this was found to make little difference in the run-time, and is advantageous when the access pattern is non-uniform\cite{brent1973reducing, sleator1985self}.

Separate-chaining is seen in Figure~\ref{types:separate}; this is more like T.D. Hanson's {\it uthash}: only being in one hash-table at a time. A similar hash to {\it $C^{++}$}'s \code{std::unordered\_map}, {\it Lua}'s \code{table}, and many others, would have another dereference between the linked-list and the entry. This style of hash-table allows unconstrained load factors. With ordered data, keeping a self-balancing tree cuts down the worst case to $\mathcal{O}(\log n)$\cite{knuth1998sorting}, as in {\it Java}. The expected number of dereferences is a constant added to the number of queries. The nodes are allocated separately from hash-table.

Open-addressing\cite{peterson1957addressing} as seen in Figure~\ref{types:open}, is another, more compact, and generally more cache-coherent table design. Robin Hood hashing\cite{celis1985robin} has been used to keep the variation in the query length to a minimum; here, with the condition on whether to evict strengthened because of the most-recently-used heuristic. It has lower maximum load-factor, because clustering decreases performance as the load-factor reaches saturation.\cite{skiena2008algorithm} Although they have less data {\it per} entry, on average they have more entries. Practically, 0.69 is high; {\it Python}'s \code{dict}\cite{knuth1998sorting} uses a maximum of \sfrac{2}{3}. One can calculate the displacement from the hash, but we have to have a general way of telling if it's null. The lack of symmetry presents a difficulty removing entries.

Inline-chaining, as seen in Figure~\ref{types:inline}, is, in many ways, a hybrid between the two. The dark circles represent the closed heads, and the outline the open stack, with a highlight to indicate the stack position. The expected probe-length is number of chained queries. Because of the \code{next} field, the space taken is one index {\it per} entry more then open-addressing. Being chained offers a higher load-factor, but it is not possible to exceed one: like open-addressing, the hash-table is contained in one block of memory.

\section{Performance}

Because the closed and open entries are orthogonal for inline-chaining, the limiting factor in the worst-case is the same as for separate-chaining, and it will have identical behaviour as long as the load-factor doesn't exceed one. In the average case, we do at least as much work by a constant factor; in addition to the steps required for chaining, we also have to sometimes also have to manage the stack. Moving the top of the stack involves finding the closed head of the top entry and iterating until the top. However, modification requires only copying one entry; we aren't concerned with the order of the stack, only the order of the next indices. However, inline-chaining does have the advantage of cache-locality.

Figure~\ref{timing} benchmarks straight insertion on a closed separately-chained set like Figure~\ref{types:separate}, an inline-chained set like Figure~\ref{types:inline}, and a \code{std::unordered\_set}. The data is a pointer to a randomly generated set of non-sense names, formed out of syllables, Poisson-distributed up to 15-letters in length; a \code{char[16]} with a null-terminator. Hashed by {\it djb2} to a 64-bit \code{size\_t}.

The same data is used for each replica across different methods, thus the same number of duplicates were ignored. The hash-tables were then destroyed for the next replica. The data is in a memory pool. Pre-allocation of the nodes of the separately-chained is done in an array; this is not counted towards the run-time; for the \code{unordered\_set}, however, this is transparent, and is timed. For the inline-chaining, it's behaviour with respect to allocation is like open-addressing: it is all contained it in one array.

\begin{figure}%
\centering%
\begin{gnuplot}[terminal=cairolatex, terminaloptions={color dashed pdf size 6.2,3.4}]
set style line 1 lt 5 lw 2 lc rgb '#0072bd' pointtype 1 pointsize 0.5
set style line 2 lt 5 lw 2 lc rgb '#ff0000' pointtype 2 pointsize 0.5
set style line 3 lt 5 lw 2 lc rgb '#00ac33' pointtype 5 pointsize 0.5
set style line 4 lt 5 lw 2 lc rgb '#19d3f5' pointtype 5 pointsize 0.5
set grid
set xlabel "insertions"
set ylabel "time per insertion, $t$ (ns)"
set yrange [0:1000]
set log x
set format x '\tiny %g'
set format y '\tiny %g'
#set tics font "Modern, 8" #rotate by 20 right # ineffectual
plot \
"../timing/graph/closed.tsv" using 1:($2/$1*1000):($3/$1*1000) with errorlines title "separate-chaining" ls 1, \
"../timing/graph/open.tsv" using 1:($2/$1*1000):($3/$1*1000) with errorlines title "inline-chaining" ls 2, \
"../timing/graph/unordered.tsv" using 1:($2/$1*1000):($3/$1*1000) with errorlines title "std$\:\:$unordered\\_set" ls 3
\end{gnuplot}
\caption{A comparison of chained techniques in a $C^{++}$ benchmark with a log-$x$ scale.}%
\label{timing}%
\end{figure}%

\section{Implementation}

This section talks about the specific implementation of inline-chained hash-table whose results are shown in Figure~\ref{timing}.

\subsection{Next Entry}

The \code{next} field in offers a convenient place to store out-of-band information without imposing restrictions on the key; specifically, we do not assume that it is non-zero. There are two special values that must be differentiated from the indices: there is no closed value associated with this address, called \code{NULL}, and there is no next value in the bucket, called \code{END}.

Since the \code{next} field must store the range of addressable buckets, minus one for itself, this is one short of representing the whole range. Since the implementation uses power-of-two resizes, it causes the addressable space to be one-bit less; we waste nearly a bit, half the size, or the equivalent of a signed integer. The values \code{NULL} and \code{END} were chosen to minimize average power requirements while leaving a natural $[0, 011..11]$ for addressing. That is, $100..00$, and $100..01$. In Figure~\ref{types:inline}, where there are 8~bits, the addressable space is $[0, 127]$, and \code{NULL}, \code{END} are 128, 129. The \code{next} theoretically takes up one-byte, but alignment issues will cause it to take more.

Since the \code{top} is an address, and the addresses only go to half the available space, we have a bit to spare. This has been used for a lazy stack. In this way, repeatedly adding and deleting to the open stack just sets the lazy bit. Only when one deletes twice does it break hysteresis loop, a move is forced.

\section{Conclusion}

This specific data for the average use-case shows the difference between separate-chaining and inline-chaining is not great enough to matter to performance, and even helps in some cases. For situations where one needs a new hash-table, the simplicity of inline-chaining is appealing.

\bibliography{tree}

\end{document}
