<!doctype html public "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<html>

<head>
<meta http-equiv = "Content-Type" content = "text/html;charset=UTF-8">
<!-- Steal these colour values from JavaDocs. -->
<style type = "text/css">
	a:link,  a:visited { color: #4a6782; }
	a:hover, a:focus   { color: #bb7a2a; }
	a:active           { color: #4A6782; }
	tr:nth-child(even) { background: #dee3e9; }
	div {
		margin:  4px 0;
		padding: 0 4px 4px 4px;
	}
	table      { width: 100%; }
	td         { padding: 4px; }
	h3, h1 {
		color: #2c4557;
		background-color: #dee3e9;
		padding:          4px;
	}
	h3 {
		margin:           0 -4px;
		padding:          4px;
	}
</style>
<title>list.h</title>
</head>

<body>

<h1>list.h</h1>

<p>Source <a href = "src/list.h">src/list.h</a>; examples <a href = "test/test_list.c">test/test_list.c</a>.</p>

<h2>Doubly-linked component</h2>

<ul>
	<li><a href = "#preamble:">Description</a></li>
	<li><a href = "#typedef:">Typedef Aliases</a>: <a href = "#typedef:<PL>action_fn">&lt;PL&gt;action_fn</a>, <a href = "#typedef:<PL>predicate_fn">&lt;PL&gt;predicate_fn</a>, <a href = "#typedef:<PSZ>to_string_fn">&lt;PSZ&gt;to_string_fn</a>, <a href = "#typedef:<PLC>bipredicate_fn">&lt;PLC&gt;bipredicate_fn</a>, <a href = "#typedef:<PLC>compare_fn">&lt;PLC&gt;compare_fn</a></li>
	<li><a href = "#tag:">Struct, Union, and Enum Definitions</a>: <a href = "#tag:<L>listlink">&lt;L&gt;listlink</a>, <a href = "#tag:<L>list">&lt;L&gt;list</a>, <a href = "#tag:<PL>iterator">&lt;PL&gt;iterator</a></li>
	<li><a href = "#summary:">Function Summary</a></li>
	<li><a href = "#fn:">Function Definitions</a></li>
	<li><a href = "#license:">License</a></li>
</ul>

<div>

<h2><a id = "preamble:" name = "preamble:">Description</a></h2>

<p><img alt = "Example of a stochastic skip-list." src = "web/list.png" width = 785 height = 556></p>

<p>In parlance of <a href = "https://scholar.google.ca/scholar?q=Thareja+2014%2C+Structures">Thareja 2014, Structures</a>, <a href = "#tag:&lt;L&gt;list">&lt;L&gt;list</a> is a circular header, or sentinel, to a doubly-linked list of <a href = "#tag:&lt;L&gt;listlink">&lt;L&gt;listlink</a>. This allows it to benefit from being closed structure, such that with with a pointer to any element, it is possible to extract the entire list.</p>

</div>

<dl>
	<dt>Parameter: LIST_NAME</dt>
	<dd><code>&lt;L&gt;</code> that satisfies <code>C</code> naming conventions when mangled; required. <code>&lt;PL&gt;</code> is private, whose names are prefixed in a manner to avoid collisions.</dd>
	<dt>Parameter: LIST_EXPECT_TRAIT</dt>
	<dd>Do not un-define certain variables for subsequent inclusion in a trait.</dd>
	<dt>Parameter: LIST_COMPARE_NAME, LIST_COMPARE, LIST_IS_EQUAL</dt>
	<dd>Compare trait contained in <a href = "src/list_coda.h">src/list_coda.h</a>. An optional mangled name for uniqueness and a function implementing either <a href = "#typedef:&lt;PLC&gt;compare_fn">&lt;PLC&gt;compare_fn</a> or <a href = "#typedef:&lt;PLC&gt;bipredicate_fn">&lt;PLC&gt;bipredicate_fn</a>.</dd>
	<dt>Parameter: LIST_TO_STRING_NAME, LIST_TO_STRING</dt>
	<dd>To string trait contained in <a href = "to_string.h">to_string.h</a>. An optional mangled name for uniqueness and function implementing <a href = "#typedef:&lt;PSZ&gt;to_string_fn">&lt;PSZ&gt;to_string_fn</a>.</dd>
	<dt>Standard:</dt>
	<dd>C89</dd>
</dl>

<h2><a id = "typedef:" name = "typedef:">Typedef Aliases</a></h2>

<div>

<h3><a id = "typedef:<PL>action_fn" name = "typedef:<PL>action_fn">&lt;PL&gt;action_fn</a></h3>

<p><code>typedef void(*<strong>&lt;PL&gt;action_fn</strong>)(struct &lt;L&gt;listlink *);</code></p>

<p>Operates by side-effects on the node.</p>

</div>

<div>

<h3><a id = "typedef:<PL>predicate_fn" name = "typedef:<PL>predicate_fn">&lt;PL&gt;predicate_fn</a></h3>

<p><code>typedef int(*<strong>&lt;PL&gt;predicate_fn</strong>)(const struct &lt;L&gt;listlink *);</code></p>

<p>Returns (Non-zero) true or (zero) false when given a node.</p>

</div>

<div>

<h3><a id = "typedef:<PSZ>to_string_fn" name = "typedef:<PSZ>to_string_fn">&lt;PSZ&gt;to_string_fn</a></h3>

<p><code>typedef void(*<strong>&lt;PSZ&gt;to_string_fn</strong>)(const &lt;PSZ&gt;type *, char(*)[12]);</code></p>

<p><a href = "to_string.h">to_string.h</a>: responsible for turning the argument into a 12-<code>char</code> null-terminated output string. <code>&lt;PSZ&gt;type</code> is contracted to be an internal iteration type of the box.</p>

</div>

<div>

<h3><a id = "typedef:<PLC>bipredicate_fn" name = "typedef:<PLC>bipredicate_fn">&lt;PLC&gt;bipredicate_fn</a></h3>

<p><code>typedef int(*<strong>&lt;PLC&gt;bipredicate_fn</strong>)(const struct &lt;L&gt;listlink *, const struct &lt;L&gt;listlink *);</code></p>

<p>Returns a boolean given two read-only <a href = "#tag:&lt;L&gt;listlink">&lt;L&gt;listlink</a>.</p>

</div>

<div>

<h3><a id = "typedef:<PLC>compare_fn" name = "typedef:<PLC>compare_fn">&lt;PLC&gt;compare_fn</a></h3>

<p><code>typedef int(*<strong>&lt;PLC&gt;compare_fn</strong>)(const struct &lt;L&gt;listlink *a, const struct &lt;L&gt;listlink *b);</code></p>

<p>Three-way comparison on a totally order set of <a href = "#tag:&lt;L&gt;listlink">&lt;L&gt;listlink</a>; returns an integer value less then, equal to, greater then zero, if <code>a &lt; b</code>, <code>a == b</code>, <code>a &gt; b</code>, respectively.</p>

</div>

<h2><a id = "tag:" name = "tag:">Struct, Union, and Enum Definitions</a></h2>

<div>

<h3><a id = "tag:<L>listlink" name = "tag:<L>listlink">&lt;L&gt;listlink</a></h3>

<p><code>struct <strong>&lt;L&gt;listlink</strong> { struct &lt;L&gt;listlink *next, *prev; };</code></p>

<p>Storage of this structure is the responsibility of the caller, who must provide a stable pointer while it's in the list. Generally, one encloses this in a host <code>struct</code> or <code>union</code>. Multiple independent lists can be in the same host, however one link can can only be a part of one list at a time. Adding a link to a second list destroys the integrity of the original list, as does moving a pointer, (specifically, arrays that might increase in size.)</p>

<p><img alt = "States." src = "web/node-states.png" width = 228 height = 231></p>

</div>

<div>

<h3><a id = "tag:<L>list" name = "tag:<L>list">&lt;L&gt;list</a></h3>

<p><code>struct <strong>&lt;L&gt;list</strong> { union { struct { struct &lt;L&gt;listlink head, *part_of_tail; } as_head; struct { struct &lt;L&gt;listlink *part_of_head, tail; } as_tail; struct { struct &lt;L&gt;listlink *next, *zero, *prev; } flat; } u; };</code></p>

<p>Serves as head and tail for linked-list of <a href = "#tag:&lt;L&gt;listlink">&lt;L&gt;listlink</a>. Use <a href = "#fn:&lt;L&gt;list_clear">&lt;L&gt;list_clear</a> to initialize the list. Because this list is closed; that is, given a valid pointer to an element, one can determine all others, null values are not allowed and it is <em>not</em> the same as <code>{0}</code>. In a valid list, <code>as_head.head.tail</code>, <code>as_tail.tail.head</code>, and <code>flat.zero</code>, refer to the same sentinel element, and it's always the only one null. If the address changes, one must call <a href = "#fn:&lt;L&gt;list_self_correct">&lt;L&gt;list_self_correct</a>.</p>

<p><img alt = "States." src = "web/states.png" width = 197 height = 409></p>

</div>

<div>

<h3><a id = "tag:<PL>iterator" name = "tag:<PL>iterator">&lt;PL&gt;iterator</a></h3>

<p><code>struct <strong>&lt;PL&gt;iterator</strong> { struct &lt;L&gt;listlink *link; };</code></p>

<p>Contains all iteration parameters. (Since this is a permutation, the iteration is defined by none other then itself. Used for traits.)</p>

</div>

<div>

<h2><a id = "summary:" name = "summary:">Function Summary</a></h2>

<table>

<tr><th>Modifiers</th><th>Function Name</th><th>Argument List</th></tr>

<tr><td align = right>static struct &lt;L&gt;listlink *</td><td><a href = "#fn:<L>list_head">&lt;L&gt;list_head</a></td><td>list</td></tr>

<tr><td align = right>static struct &lt;L&gt;listlink *</td><td><a href = "#fn:<L>list_tail">&lt;L&gt;list_tail</a></td><td>list</td></tr>

<tr><td align = right>static struct &lt;L&gt;listlink *</td><td><a href = "#fn:<L>list_previous">&lt;L&gt;list_previous</a></td><td>link</td></tr>

<tr><td align = right>static struct &lt;L&gt;listlink *</td><td><a href = "#fn:<L>list_next">&lt;L&gt;list_next</a></td><td>link</td></tr>

<tr><td align = right>static void</td><td><a href = "#fn:<L>list_clear">&lt;L&gt;list_clear</a></td><td>list</td></tr>

<tr><td align = right>static void</td><td><a href = "#fn:<L>list_add_before">&lt;L&gt;list_add_before</a></td><td>anchor, add</td></tr>

<tr><td align = right>static void</td><td><a href = "#fn:<L>list_add_after">&lt;L&gt;list_add_after</a></td><td>anchor, add</td></tr>

<tr><td align = right>static void</td><td><a href = "#fn:<L>list_push">&lt;L&gt;list_push</a></td><td>list, add</td></tr>

<tr><td align = right>static void</td><td><a href = "#fn:<L>list_unshift">&lt;L&gt;list_unshift</a></td><td>list, add</td></tr>

<tr><td align = right>static void</td><td><a href = "#fn:<L>list_remove">&lt;L&gt;list_remove</a></td><td>node</td></tr>

<tr><td align = right>static struct &lt;L&gt;listlink *</td><td><a href = "#fn:<L>list_shift">&lt;L&gt;list_shift</a></td><td>list</td></tr>

<tr><td align = right>static struct &lt;L&gt;listlink *</td><td><a href = "#fn:<L>list_pop">&lt;L&gt;list_pop</a></td><td>list</td></tr>

<tr><td align = right>static void</td><td><a href = "#fn:<L>list_to">&lt;L&gt;list_to</a></td><td>from, to</td></tr>

<tr><td align = right>static void</td><td><a href = "#fn:<L>list_to_before">&lt;L&gt;list_to_before</a></td><td>from, anchor</td></tr>

<tr><td align = right>static void</td><td><a href = "#fn:<L>list_to_if">&lt;L&gt;list_to_if</a></td><td>from, to, predicate</td></tr>

<tr><td align = right>static void</td><td><a href = "#fn:<L>list_for_each">&lt;L&gt;list_for_each</a></td><td>list, action</td></tr>

<tr><td align = right>static struct &lt;L&gt;listlink *</td><td><a href = "#fn:<L>list_any">&lt;L&gt;list_any</a></td><td>list, predicate</td></tr>

<tr><td align = right>static void</td><td><a href = "#fn:<L>list_self_correct">&lt;L&gt;list_self_correct</a></td><td>list</td></tr>

<tr><td align = right>static const char *</td><td><a href = "#fn:<SZ>to_string">&lt;SZ&gt;to_string</a></td><td>box</td></tr>

<tr><td align = right>static int</td><td><a href = "#fn:<LC>compare">&lt;LC&gt;compare</a></td><td>alist, blist</td></tr>

<tr><td align = right>static void</td><td><a href = "#fn:<LC>sort">&lt;LC&gt;sort</a></td><td>list</td></tr>

<tr><td align = right>static void</td><td><a href = "#fn:<LC>subtraction_to">&lt;LC&gt;subtraction_to</a></td><td>a, b, result</td></tr>

<tr><td align = right>static void</td><td><a href = "#fn:<LC>union_to">&lt;LC&gt;union_to</a></td><td>a, b, result</td></tr>

<tr><td align = right>static void</td><td><a href = "#fn:<LC>intersection_to">&lt;LC&gt;intersection_to</a></td><td>a, b, result</td></tr>

<tr><td align = right>static void</td><td><a href = "#fn:<LC>xor_to">&lt;LC&gt;xor_to</a></td><td>a, b, result</td></tr>

<tr><td align = right>static int</td><td><a href = "#fn:<LC>is_equal">&lt;LC&gt;is_equal</a></td><td>lista, listb</td></tr>

<tr><td align = right>static void</td><td><a href = "#fn:<LC>duplicates_to">&lt;LC&gt;duplicates_to</a></td><td>from, to</td></tr>

</table>

</div>

<div>

<h2><a id = "fn:" name = "fn:">Function Definitions</a></h2>

<div>

<h3><a id = "fn:<L>list_head" name = "fn:<L>list_head">&lt;L&gt;list_head</a></h3>

<p><code>static struct &lt;L&gt;listlink *<strong>&lt;L&gt;list_head</strong>(const struct &lt;L&gt;list *const <em>list</em>)</code></p>

<dl>
	<dt>Return:</dt>
	<dd>A pointer to the first element of <code>list</code>, if it exists.</dd>
	<dt>Order:</dt>
	<dd>&#920;(1)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<L>list_tail" name = "fn:<L>list_tail">&lt;L&gt;list_tail</a></h3>

<p><code>static struct &lt;L&gt;listlink *<strong>&lt;L&gt;list_tail</strong>(const struct &lt;L&gt;list *const <em>list</em>)</code></p>

<dl>
	<dt>Return:</dt>
	<dd>A pointer to the last element of <code>list</code>, if it exists.</dd>
	<dt>Order:</dt>
	<dd>&#920;(1)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<L>list_previous" name = "fn:<L>list_previous">&lt;L&gt;list_previous</a></h3>

<p><code>static struct &lt;L&gt;listlink *<strong>&lt;L&gt;list_previous</strong>(struct &lt;L&gt;listlink *<em>link</em>)</code></p>

<dl>
	<dt>Return:</dt>
	<dd>The previous element. When <code>link</code> is the first element, returns null.</dd>
	<dt>Order:</dt>
	<dd>&#920;(1)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<L>list_next" name = "fn:<L>list_next">&lt;L&gt;list_next</a></h3>

<p><code>static struct &lt;L&gt;listlink *<strong>&lt;L&gt;list_next</strong>(struct &lt;L&gt;listlink *<em>link</em>)</code></p>

<dl>
	<dt>Return:</dt>
	<dd>The next element. When <code>link</code> is the last element, returns null.</dd>
	<dt>Order:</dt>
	<dd>&#920;(1)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<L>list_clear" name = "fn:<L>list_clear">&lt;L&gt;list_clear</a></h3>

<p><code>static void <strong>&lt;L&gt;list_clear</strong>(struct &lt;L&gt;list *const <em>list</em>)</code></p>

<p>Clears and initializes <code>list</code>.</p>

<dl>
	<dt>Order:</dt>
	<dd>&#920;(1)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<L>list_add_before" name = "fn:<L>list_add_before">&lt;L&gt;list_add_before</a></h3>

<p><code>static void <strong>&lt;L&gt;list_add_before</strong>(struct &lt;L&gt;listlink *const <em>anchor</em>, struct &lt;L&gt;listlink *const <em>add</em>)</code></p>

<p><code>add</code> before <code>anchor</code>.</p>

<dl>
	<dt>Order:</dt>
	<dd>&#920;(1)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<L>list_add_after" name = "fn:<L>list_add_after">&lt;L&gt;list_add_after</a></h3>

<p><code>static void <strong>&lt;L&gt;list_add_after</strong>(struct &lt;L&gt;listlink *const <em>anchor</em>, struct &lt;L&gt;listlink *const <em>add</em>)</code></p>

<p><code>add</code> after <code>anchor</code>.</p>

<dl>
	<dt>Order:</dt>
	<dd>&#920;(1)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<L>list_push" name = "fn:<L>list_push">&lt;L&gt;list_push</a></h3>

<p><code>static void <strong>&lt;L&gt;list_push</strong>(struct &lt;L&gt;list *const <em>list</em>, struct &lt;L&gt;listlink *const <em>add</em>)</code></p>

<p>Adds <code>add</code> to the end of <code>list</code>.</p>

<dl>
	<dt>Order:</dt>
	<dd>&#920;(1)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<L>list_unshift" name = "fn:<L>list_unshift">&lt;L&gt;list_unshift</a></h3>

<p><code>static void <strong>&lt;L&gt;list_unshift</strong>(struct &lt;L&gt;list *const <em>list</em>, struct &lt;L&gt;listlink *const <em>add</em>)</code></p>

<p>Adds <code>add</code> to the beginning of <code>list</code>.</p>

<dl>
	<dt>Order:</dt>
	<dd>&#920;(1)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<L>list_remove" name = "fn:<L>list_remove">&lt;L&gt;list_remove</a></h3>

<p><code>static void <strong>&lt;L&gt;list_remove</strong>(struct &lt;L&gt;listlink *const <em>node</em>)</code></p>

<p>Remove <code>node</code>.</p>

<dl>
	<dt>Order:</dt>
	<dd>&#920;(1)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<L>list_shift" name = "fn:<L>list_shift">&lt;L&gt;list_shift</a></h3>

<p><code>static struct &lt;L&gt;listlink *<strong>&lt;L&gt;list_shift</strong>(struct &lt;L&gt;list *const <em>list</em>)</code></p>

<p>Removes the first element of <code>list</code> and returns it, if any.</p>

<dl>
	<dt>Order:</dt>
	<dd>&#920;(1)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<L>list_pop" name = "fn:<L>list_pop">&lt;L&gt;list_pop</a></h3>

<p><code>static struct &lt;L&gt;listlink *<strong>&lt;L&gt;list_pop</strong>(struct &lt;L&gt;list *const <em>list</em>)</code></p>

<p>Removes the last element of <code>list</code> and returns it, if any.</p>

<dl>
	<dt>Order:</dt>
	<dd>&#920;(1)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<L>list_to" name = "fn:<L>list_to">&lt;L&gt;list_to</a></h3>

<p><code>static void <strong>&lt;L&gt;list_to</strong>(struct &lt;L&gt;list *const <em>from</em>, struct &lt;L&gt;list *const <em>to</em>)</code></p>

<p>Moves the elements <code>from</code> onto <code>to</code> at the end.</p>

<dl>
	<dt>Parameter: <em>to</em></dt>
	<dd>If null, then it removes elements from <code>from</code>.</dd>
	<dt>Order:</dt>
	<dd>&#920;(1)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<L>list_to_before" name = "fn:<L>list_to_before">&lt;L&gt;list_to_before</a></h3>

<p><code>static void <strong>&lt;L&gt;list_to_before</strong>(struct &lt;L&gt;list *const <em>from</em>, struct &lt;L&gt;listlink *const <em>anchor</em>)</code></p>

<p>Moves the elements <code>from</code> immediately before <code>anchor</code>, which can not be in the same list.</p>

<dl>
	<dt>Order:</dt>
	<dd>&#920;(1)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<L>list_to_if" name = "fn:<L>list_to_if">&lt;L&gt;list_to_if</a></h3>

<p><code>static void <strong>&lt;L&gt;list_to_if</strong>(struct &lt;L&gt;list *const <em>from</em>, struct &lt;L&gt;list *const <em>to</em>, const &lt;PL&gt;predicate_fn <em>predicate</em>)</code></p>

<p>Moves all elements <code>from</code> onto <code>to</code> at the tail if <code>predicate</code> is true. They ca'n't be the same list.</p>

<dl>
	<dt>Parameter: <em>to</em></dt>
	<dd>If null, then it removes elements.</dd>
	<dt>Order:</dt>
	<dd>&#920;(|<code>from</code>|) &#215; &#927;(<code>predicate</code>)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<L>list_for_each" name = "fn:<L>list_for_each">&lt;L&gt;list_for_each</a></h3>

<p><code>static void <strong>&lt;L&gt;list_for_each</strong>(struct &lt;L&gt;list *const <em>list</em>, const &lt;PL&gt;action_fn <em>action</em>)</code></p>

<p>Performs <code>action</code> for each element in <code>list</code> in order.</p>

<dl>
	<dt>Parameter: <em>action</em></dt>
	<dd>It makes a double of the next node, so it can be to delete the element and even assign it's values null.</dd>
	<dt>Order:</dt>
	<dd>&#920;(|<code>list</code>|) &#215; O(<code>action</code>)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<L>list_any" name = "fn:<L>list_any">&lt;L&gt;list_any</a></h3>

<p><code>static struct &lt;L&gt;listlink *<strong>&lt;L&gt;list_any</strong>(const struct &lt;L&gt;list *const <em>list</em>, const &lt;PL&gt;predicate_fn <em>predicate</em>)</code></p>

<p>Iterates through <code>list</code> and calls <code>predicate</code> until it returns true.</p>

<dl>
	<dt>Return:</dt>
	<dd>The first <code>predicate</code> that returned true, or, if the statement is false on all, null.</dd>
	<dt>Order:</dt>
	<dd>&#927;(|<code>list</code>|) &#215; &#927;(<code>predicate</code>)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<L>list_self_correct" name = "fn:<L>list_self_correct">&lt;L&gt;list_self_correct</a></h3>

<p><code>static void <strong>&lt;L&gt;list_self_correct</strong>(struct &lt;L&gt;list *const <em>list</em>)</code></p>

<p>Corrects <code>list</code> ends to compensate for memory relocation of the list itself. Because the <code>list</code> is part of the links, this will invalidate all other copies.</p>

<dl>
	<dt>Order:</dt>
	<dd>&#920;(1)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<SZ>to_string" name = "fn:<SZ>to_string">&lt;SZ&gt;to_string</a></h3>

<p><code>static const char *<strong>&lt;SZ&gt;to_string</strong>(const &lt;PSZ&gt;box *const <em>box</em>)</code></p>

<p><a href = "to_string.h">to_string.h</a>: print the contents of <code>box</code> in a static string buffer of 256 bytes, with limitations of only printing 4 things at a time. <code>&lt;PSZ&gt;box</code> is contracted to be the box itself. <code>&lt;SZ&gt;</code> is loosely contracted to be a name <code>&lt;X&gt;box[&lt;X_TO_STRING_NAME&gt;]</code>.</p>

<dl>
	<dt>Return:</dt>
	<dd>Address of the static buffer.</dd>
	<dt>Order:</dt>
	<dd>&#920;(1)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<LC>compare" name = "fn:<LC>compare">&lt;LC&gt;compare</a></h3>

<p><code>static int <strong>&lt;LC&gt;compare</strong>(const struct &lt;L&gt;list *const <em>alist</em>, const struct &lt;L&gt;list *const <em>blist</em>)</code></p>

<p>Lexicographically compares <code>alist</code> to <code>blist</code>. Null values are before everything.</p>

<dl>
	<dt>Return:</dt>
	<dd><code>a &lt; b</code>: negative; <code>a == b</code>: zero; <code>a &gt; b</code>: positive.</dd>
	<dt>Implements:</dt>
	<dd><a href = "#typedef:&lt;PLC&gt;compare_fn">&lt;PLC&gt;compare_fn</a> (one can <code>qsort</code> an array of lists, as long as one calls <a href = "#fn:&lt;L&gt;list_self_correct">&lt;L&gt;list_self_correct</a> on it's elements)</dd>
	<dt>Order:</dt>
	<dd>&#920;(min(|<code>alist</code>|, |<code>blist</code>|))</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<LC>sort" name = "fn:<LC>sort">&lt;LC&gt;sort</a></h3>

<p><code>static void <strong>&lt;LC&gt;sort</strong>(struct &lt;L&gt;list *const <em>list</em>)</code></p>

<p>Performs a stable, adaptive sort of <code>list</code> according to <code>compare</code>.</p>

<dl>
	<dt>Order:</dt>
	<dd>&#937;(|<code>list</code>|), &#927;(|<code>list</code>| log |<code>list</code>|)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<LC>subtraction_to" name = "fn:<LC>subtraction_to">&lt;LC&gt;subtraction_to</a></h3>

<p><code>static void <strong>&lt;LC&gt;subtraction_to</strong>(struct &lt;L&gt;list *const <em>a</em>, struct &lt;L&gt;list *const <em>b</em>, struct &lt;L&gt;list *const <em>result</em>)</code></p>

<p>Subtracts <code>a</code> from <code>b</code>, as sequential sorted individual elements, and moves it to <code>result</code>. All elements are removed from <code>a</code>. All parameters must be unique or can be null.</p>

<p>For example, if <code>a</code> contains <code>(A, B, D)</code> and <code>b</code> contains <code>(B, C)</code> then <code>(a:A, a:D)</code> would be moved to <code>result</code>.</p>

</div>

<dl>
	<dt>Order:</dt>
	<dd>&#927;(|<code>a</code>| + |<code>b</code>|)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<LC>union_to" name = "fn:<LC>union_to">&lt;LC&gt;union_to</a></h3>

<p><code>static void <strong>&lt;LC&gt;union_to</strong>(struct &lt;L&gt;list *const <em>a</em>, struct &lt;L&gt;list *const <em>b</em>, struct &lt;L&gt;list *const <em>result</em>)</code></p>

<p>Moves the union of <code>a</code> and <code>b</code> as sequential sorted individual elements to <code>result</code>. Equal elements are moved from <code>a</code>. All parameters must be unique or can be null.</p>

<p>For example, if <code>a</code> contains <code>(A, B, D)</code> and <code>b</code> contains <code>(B, C)</code> then <code>(a:A, a:B, b:C, a:D)</code> would be moved to <code>result</code>.</p>

</div>

<dl>
	<dt>Order:</dt>
	<dd>&#927;(|<code>a</code>| + |<code>b</code>|)</dd>
</dl>

<div>

<h3><a id = "fn:<LC>intersection_to" name = "fn:<LC>intersection_to">&lt;LC&gt;intersection_to</a></h3>

<p><code>static void <strong>&lt;LC&gt;intersection_to</strong>(struct &lt;L&gt;list *const <em>a</em>, struct &lt;L&gt;list *const <em>b</em>, struct &lt;L&gt;list *const <em>result</em>)</code></p>

<p>Moves the intersection of <code>a</code> and <code>b</code> as sequential sorted individual elements to <code>result</code>. Equal elements are moved from <code>a</code>. All parameters must be unique or can be null.</p>

<p>For example, if <code>a</code> contains <code>(A, B, D)</code> and <code>b</code> contains <code>(B, C)</code> then <code>(a:B)</code> would be moved to <code>result</code>.</p>

</div>

<dl>
	<dt>Order:</dt>
	<dd>&#927;(|<code>a</code>| + |<code>b</code>|)</dd>
</dl>

<div>

<h3><a id = "fn:<LC>xor_to" name = "fn:<LC>xor_to">&lt;LC&gt;xor_to</a></h3>

<p><code>static void <strong>&lt;LC&gt;xor_to</strong>(struct &lt;L&gt;list *const <em>a</em>, struct &lt;L&gt;list *const <em>b</em>, struct &lt;L&gt;list *const <em>result</em>)</code></p>

<p>Moves <code>a</code> exclusive-or <code>b</code> as sequential sorted individual elements to <code>result</code>. Equal elements are moved from <code>a</code>. All parameters must be unique or can be null.</p>

<p>For example, if <code>a</code> contains <code>(A, B, D)</code> and <code>b</code> contains <code>(B, C)</code> then <code>(a:A, b:C, a:D)</code> would be moved to <code>result</code>.</p>

</div>

<dl>
	<dt>Order:</dt>
	<dd>O(|<code>a</code>| + |<code>b</code>|)</dd>
</dl>

<div>

<h3><a id = "fn:<LC>is_equal" name = "fn:<LC>is_equal">&lt;LC&gt;is_equal</a></h3>

<p><code>static int <strong>&lt;LC&gt;is_equal</strong>(const struct &lt;L&gt;list *const <em>lista</em>, const struct &lt;L&gt;list *const <em>listb</em>)</code></p>

<dl>
	<dt>Return:</dt>
	<dd>If <code>lista</code> piecewise equals <code>listb</code>, which both can be null.</dd>
	<dt>Order:</dt>
	<dd>&#927;(min(|<code>lista</code>|, |<code>listb</code>|))</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<LC>duplicates_to" name = "fn:<LC>duplicates_to">&lt;LC&gt;duplicates_to</a></h3>

<p><code>static void <strong>&lt;LC&gt;duplicates_to</strong>(struct &lt;L&gt;list *const <em>from</em>, struct &lt;L&gt;list *const <em>to</em>)</code></p>

<p>Moves all local-duplicates of <code>from</code> to the end of <code>to</code>.</p>

<p>For example, if <code>from</code> is <code>(A, B, B, A)</code>, it would concatenate the second <code>(B)</code> to <code>to</code> and leave <code>(A, B, A)</code> in <code>from</code>. If one <a href = "#fn:&lt;LC&gt;sort">&lt;LC&gt;sort</a> <code>from</code> first, <code>(A, A, B, B)</code>, the global duplicates will be transferred, <code>(A, B)</code>.</p>

</div>

<dl>
	<dt>Order:</dt>
	<dd>&#927;(|<code>from</code>|)</dd>
</dl>

<div>

<h2><a id = "license:" name = "license:">License</a></h2>

<p>2017 Neil Edelman, distributed under the terms of the <a href = "https://opensource.org/licenses/MIT">MIT License</a>.</p>

</div>

</body>

</html>
