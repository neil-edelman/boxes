<!doctype html public "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<html>

<head>
<meta http-equiv = "Content-Type" content = "text/html;charset=UTF-8">
<!-- Steal these colour values from JavaDocs. -->
<style type = "text/css">
	a:link,  a:visited { color: #4a6782; }
	a:hover, a:focus   { color: #bb7a2a; }
	a:active           { color: #4A6782; }
	tr:nth-child(even) { background: #dee3e9; }
	div {
		margin:  4px 0;
		padding: 0 4px 4px 4px;
	}
	table      { width: 100%; }
	td         { padding: 4px; }
	h3, h1 {
		color: #2c4557;
		background-color: #dee3e9;
		padding:          4px;
	}
	h3 {
		margin:           0 -4px;
		padding:          4px;
	}
</style>
<title>table.h</title>
</head>

<body>

<h1>table.h</h1>

<p>Stand-alone header <a href = "src/table.h">src/table.h</a>; examples <a href = "test/test_table.c">test/test_table.c</a>; article <a href = "doc/table.pdf">doc/table.pdf</a>. On a compatible workstation, <code>make</code> creates the test suite of the examples.</p>

<h2>Hash table</h2>

<ul>
	<li><a href = "#preamble:">Description</a></li>
	<li><a href = "#typedef:">Typedef Aliases</a>: <a href = "#typedef:<PN>uint">&lt;PN&gt;uint</a>, <a href = "#typedef:<PN>key">&lt;PN&gt;key</a>, <a href = "#typedef:<PN>hash_fn">&lt;PN&gt;hash_fn</a>, <a href = "#typedef:<PN>inverse_hash_fn">&lt;PN&gt;inverse_hash_fn</a>, <a href = "#typedef:<PN>is_equal_fn">&lt;PN&gt;is_equal_fn</a>, <a href = "#typedef:<PN>value">&lt;PN&gt;value</a>, <a href = "#typedef:<PN>entry">&lt;PN&gt;entry</a>, <a href = "#typedef:<PN>policy_fn">&lt;PN&gt;policy_fn</a>, <a href = "#typedef:<PITR>action_fn">&lt;PITR&gt;action_fn</a>, <a href = "#typedef:<PITR>predicate_fn">&lt;PITR&gt;predicate_fn</a>, <a href = "#typedef:<PSTR>to_string_fn">&lt;PSTR&gt;to_string_fn</a></li>
	<li><a href = "#tag:">Struct, Union, and Enum Definitions</a>: <a href = "#tag:table_result">table_result</a>, <a href = "#tag:<N>table_entry">&lt;N&gt;table_entry</a>, <a href = "#tag:<N>table">&lt;N&gt;table</a>, <a href = "#tag:<N>table_iterator">&lt;N&gt;table_iterator</a></li>
	<li><a href = "#summary:">Function Summary</a></li>
	<li><a href = "#fn:">Function Definitions</a></li>
	<li><a href = "#license:">License</a></li>
</ul>

<div>

<h2><a id = "preamble:" name = "preamble:">Description</a></h2>

<p><img alt = "Example of &lt;string&gt;table." src = "doc/table.png" width = 388 height = 391></p>

<p><a href = "#tag:&lt;N&gt;table">&lt;N&gt;table</a> implements a set or map of <a href = "#typedef:&lt;PN&gt;entry">&lt;PN&gt;entry</a> as a hash table. It must be supplied a <a href = "#typedef:&lt;PN&gt;hash_fn">&lt;PN&gt;hash_fn</a> and, <a href = "#typedef:&lt;PN&gt;is_equal_fn">&lt;PN&gt;is_equal_fn</a> or <a href = "#typedef:&lt;PN&gt;inverse_hash_fn">&lt;PN&gt;inverse_hash_fn</a>.</p>

</div>

<dl>
	<dt>Parameter: TABLE_NAME, TABLE_KEY</dt>
	<dd><code>&lt;N&gt;</code> that satisfies <code>C</code> naming conventions when mangled and a valid <a href = "#typedef:&lt;PN&gt;key">&lt;PN&gt;key</a> associated therewith; required. <code>&lt;PN&gt;</code> is private, whose names are prefixed in a manner to avoid collisions.</dd>
	<dt>Parameter: TABLE_HASH, TABLE_IS_EQUAL, TABLE_INVERSE</dt>
	<dd><code>TABLE_HASH</code>, and either <code>TABLE_IS_EQUAL</code> or <code>TABLE_INVERSE</code>, but not both, are required. Function satisfying <a href = "#typedef:&lt;PN&gt;hash_fn">&lt;PN&gt;hash_fn</a>, and <a href = "#typedef:&lt;PN&gt;is_equal_fn">&lt;PN&gt;is_equal_fn</a> or <a href = "#typedef:&lt;PN&gt;inverse_hash_fn">&lt;PN&gt;inverse_hash_fn</a>.</dd>
	<dt>Parameter: TABLE_VALUE</dt>
	<dd>An optional type that is the payload of the key, thus making this a map or associative array. (If the key is part of an aggregate pointer, it will be more efficient and robust to use a set with a type conversion instead of storing related pointers in a map.)</dd>
	<dt>Parameter: TABLE_UINT</dt>
	<dd>This is <a href = "#typedef:&lt;PN&gt;uint">&lt;PN&gt;uint</a>, the unsigned type of hash hash of the key given by <a href = "#typedef:&lt;PN&gt;hash_fn">&lt;PN&gt;hash_fn</a>; defaults to <code>size_t</code>.</dd>
	<dt>Parameter: TABLE_EXPECT_TRAIT</dt>
	<dd>Do not un-define certain variables for subsequent inclusion in a trait.</dd>
	<dt>Parameter: TABLE_DEFAULT_NAME, TABLE_DEFAULT</dt>
	<dd>Default trait; a name that satisfies <code>C</code> naming conventions when mangled and a <a href = "#typedef:&lt;PN&gt;value">&lt;PN&gt;value</a> used in <a href = "#fn:&lt;N&gt;table&lt;D&gt;get">&lt;N&gt;table&lt;D&gt;get</a>. There can be multiple defaults, but only one can omit <code>TABLE_DEFAULT_NAME</code>.</dd>
	<dt>Parameter: TABLE_TO_STRING_NAME, TABLE_TO_STRING</dt>
	<dd>To string trait contained in <a href = "to_string.h">to_string.h</a>; <code>&lt;STR&gt;</code> that satisfies <code>C</code> naming conventions when mangled and function implementing <a href = "#typedef:&lt;PSTR&gt;to_string_fn">&lt;PSTR&gt;to_string_fn</a>. There can be multiple to string traits, but only one can omit <code>TABLE_TO_STRING_NAME</code>.</dd>
	<dt>Parameter: HAVE_ITERATE_H</dt>
	<dd>The <code>&lt;ITR&gt;</code> functions need this value. This includes <a href = "src/iterate.h">src/iterate.h</a>, which take no parameters. Some functions may only be available for some boxes. This does not expire after box completion.</dd>
	<dt>Standard:</dt>
	<dd>C89</dd>
</dl>

<h2><a id = "typedef:" name = "typedef:">Typedef Aliases</a></h2>

<div>

<h3><a id = "typedef:<PN>uint" name = "typedef:<PN>uint">&lt;PN&gt;uint</a></h3>

<p><code>typedef TABLE_UINT <strong>&lt;PN&gt;uint</strong>;</code></p>

<p><a href = "#typedef:&lt;PN&gt;hash_fn">&lt;PN&gt;hash_fn</a> returns this hash type by <code>TABLE_UINT</code>, which must be be an unsigned integer. Places a simplifying limit on the maximum number of elements of half the cardinality.</p>

</div>

<div>

<h3><a id = "typedef:<PN>key" name = "typedef:<PN>key">&lt;PN&gt;key</a></h3>

<p><code>typedef TABLE_KEY <strong>&lt;PN&gt;key</strong>;</code></p>

<p>Valid tag type defined by <code>TABLE_KEY</code> used for keys. If <code>TABLE_INVERSE</code> is not defined, a copy of this value will be stored in the internal buckets.</p>

</div>

<div>

<h3><a id = "typedef:<PN>hash_fn" name = "typedef:<PN>hash_fn">&lt;PN&gt;hash_fn</a></h3>

<p><code>typedef &lt;PN&gt;uint(*<strong>&lt;PN&gt;hash_fn</strong>)(&lt;PN&gt;key_c);</code></p>

<p>A map from <a href = "#typedef:&lt;PN&gt;key_c">&lt;PN&gt;key_c</a> onto <a href = "#typedef:&lt;PN&gt;uint">&lt;PN&gt;uint</a> that, ideally, should be easy to compute while minimizing duplicate addresses. Must be consistent for each value while in the table. If <a href = "#typedef:&lt;PN&gt;key">&lt;PN&gt;key</a> is a pointer, one is permitted to have null in the domain.</p>

</div>

<div>

<h3><a id = "typedef:<PN>inverse_hash_fn" name = "typedef:<PN>inverse_hash_fn">&lt;PN&gt;inverse_hash_fn</a></h3>

<p><code>typedef &lt;PN&gt;key(*<strong>&lt;PN&gt;inverse_hash_fn</strong>)(&lt;PN&gt;uint);</code></p>

<p>Defining <code>TABLE_INVERSE</code> says <a href = "#typedef:&lt;PN&gt;hash_fn">&lt;PN&gt;hash_fn</a> forms a bijection between the range in <a href = "#typedef:&lt;PN&gt;key">&lt;PN&gt;key</a> and the image in <a href = "#typedef:&lt;PN&gt;uint">&lt;PN&gt;uint</a>. Keys are not stored in the hash table, rather they are generated using this inverse-mapping.</p>

</div>

<div>

<h3><a id = "typedef:<PN>is_equal_fn" name = "typedef:<PN>is_equal_fn">&lt;PN&gt;is_equal_fn</a></h3>

<p><code>typedef int(*<strong>&lt;PN&gt;is_equal_fn</strong>)(&lt;PN&gt;key_c a, &lt;PN&gt;key_c b);</code></p>

<p>Equivalence relation between <a href = "#typedef:&lt;PN&gt;key">&lt;PN&gt;key</a> that satisfies <code>&lt;PN&gt;is_equal_fn(a, b) -&gt; &lt;PN&gt;hash(a) == &lt;PN&gt;hash(b)</code>. Can not be set if <code>TABLE_INVERSE</code>, because the comparison is done directly in hash space, in that case.</p>

</div>

<div>

<h3><a id = "typedef:<PN>value" name = "typedef:<PN>value">&lt;PN&gt;value</a></h3>

<p><code>typedef TABLE_VALUE <strong>&lt;PN&gt;value</strong>;</code></p>

<p>Defining <code>TABLE_VALUE</code> produces an associative map, otherwise it is the same as <a href = "#typedef:&lt;PN&gt;key">&lt;PN&gt;key</a>.</p>

</div>

<div>

<h3><a id = "typedef:<PN>entry" name = "typedef:<PN>entry">&lt;PN&gt;entry</a></h3>

<p><code>typedef struct &lt;N&gt;table_entry <strong>&lt;PN&gt;entry</strong>;</code></p>

<p>If <code>TABLE_VALUE</code>, this is <a href = "#tag:&lt;N&gt;table_entry">&lt;N&gt;table_entry</a>; otherwise, it's the same as <a href = "#typedef:&lt;PN&gt;key">&lt;PN&gt;key</a>.</p>

</div>

<div>

<h3><a id = "typedef:<PN>policy_fn" name = "typedef:<PN>policy_fn">&lt;PN&gt;policy_fn</a></h3>

<p><code>typedef int(*<strong>&lt;PN&gt;policy_fn</strong>)(&lt;PN&gt;key original, &lt;PN&gt;key replace);</code></p>

<p>Returns true if the <code>replace</code> replaces the <code>original</code>. (Shouldn't it be entry?)</p>

</div>

<div>

<h3><a id = "typedef:<PITR>action_fn" name = "typedef:<PITR>action_fn">&lt;PITR&gt;action_fn</a></h3>

<p><code>typedef void(*<strong>&lt;PITR&gt;action_fn</strong>)(&lt;PITR&gt;element);</code></p>

<p><a href = "src/iterate.h">src/iterate.h</a>: Operates by side-effects.</p>

</div>

<div>

<h3><a id = "typedef:<PITR>predicate_fn" name = "typedef:<PITR>predicate_fn">&lt;PITR&gt;predicate_fn</a></h3>

<p><code>typedef int(*<strong>&lt;PITR&gt;predicate_fn</strong>)(const &lt;PITR&gt;element_c);</code></p>

<p><a href = "src/iterate.h">src/iterate.h</a>: Returns a boolean given read-only.</p>

</div>

<div>

<h3><a id = "typedef:<PSTR>to_string_fn" name = "typedef:<PSTR>to_string_fn">&lt;PSTR&gt;to_string_fn</a></h3>

<p><code>typedef void(*<strong>&lt;PSTR&gt;to_string_fn</strong>)(&lt;PSTR&gt;element_c, char(*)[12]);</code></p>

<p><a href = "src/to_string.h">src/to_string.h</a>: responsible for turning the argument into a 12-<code>char</code> null-terminated output string.</p>

</div>

<h2><a id = "tag:" name = "tag:">Struct, Union, and Enum Definitions</a></h2>

<div>

<h3><a id = "tag:table_result" name = "tag:table_result">table_result</a></h3>

<p><code>enum <strong>table_result</strong> { TABLE_RESULT };</code></p>

<p>A result of modifying the table, of which <code>TABLE_ERROR</code> is false.</p>

<p><img alt = "A diagram of the result states." src = "doc/put.png" width = 735 height = 321></p>

</div>

<div>

<h3><a id = "tag:<N>table_entry" name = "tag:<N>table_entry">&lt;N&gt;table_entry</a></h3>

<p><code>struct <strong>&lt;N&gt;table_entry</strong> { &lt;PN&gt;key key; &lt;PN&gt;value value; };</code></p>

<p>Defining <code>TABLE_VALUE</code> creates this map from <a href = "#typedef:&lt;PN&gt;key">&lt;PN&gt;key</a> to <a href = "#typedef:&lt;PN&gt;value">&lt;PN&gt;value</a>, as an interface with table.</p>

</div>

<div>

<h3><a id = "tag:<N>table" name = "tag:<N>table">&lt;N&gt;table</a></h3>

<p><code>struct <strong>&lt;N&gt;table</strong> { struct &lt;PN&gt;bucket *buckets; &lt;PN&gt;uint log_capacity, size, top; };</code></p>

<p>To initialize, see <a href = "#fn:&lt;N&gt;table">&lt;N&gt;table</a>, <code>TABLE_IDLE</code>, <code>{0}</code> (<code>C99</code>,) or being <code>static</code>. The fields should be treated as read-only; any modification is liable to cause the table to go into an invalid state.</p>

<p><img alt = "States." src = "doc/states.png" width = 912 height = 152></p>

</div>

<div>

<h3><a id = "tag:<N>table_iterator" name = "tag:<N>table_iterator">&lt;N&gt;table_iterator</a></h3>

<p><code>struct <strong>&lt;N&gt;table_iterator</strong>;</code></p>

<p><img alt = "States" src = "doc/it.png" width = 943 height = 117></p>

<p>Adding, deleting, successfully looking up entries, or any modification of the table's topology invalidates the iterator. Iteration usually not in any particular order. The asymptotic runtime of iterating though the whole table is proportional to the capacity.</p>

</div>

<div>

<h2><a id = "summary:" name = "summary:">Function Summary</a></h2>

<table>

<tr><th>Modifiers</th><th>Function Name</th><th>Argument List</th></tr>

<tr><td align = right>static struct &lt;N&gt;table</td><td><a href = "#fn:<N>table">&lt;N&gt;table</a></td><td></td></tr>

<tr><td align = right>static void</td><td><a href = "#fn:<N>table_">&lt;N&gt;table_</a></td><td>table</td></tr>

<tr><td align = right>static struct &lt;N&gt;table_iterator</td><td><a href = "#fn:<N>table_begin">&lt;N&gt;table_begin</a></td><td>table</td></tr>

<tr><td align = right>static int</td><td><a href = "#fn:<N>table_next">&lt;N&gt;table_next</a></td><td>it, entry</td></tr>

<tr><td align = right>static int</td><td><a href = "#fn:<N>table_has_next">&lt;N&gt;table_has_next</a></td><td>it</td></tr>

<tr><td align = right>static &lt;PN&gt;key</td><td><a href = "#fn:<N>table_next_key">&lt;N&gt;table_next_key</a></td><td>it</td></tr>

<tr><td align = right>static &lt;PN&gt;value</td><td><a href = "#fn:<N>table_next_value">&lt;N&gt;table_next_value</a></td><td>it</td></tr>

<tr><td align = right>static int</td><td><a href = "#fn:<N>table_iterator_remove">&lt;N&gt;table_iterator_remove</a></td><td>it</td></tr>

<tr><td align = right>static int</td><td><a href = "#fn:<N>table_buffer">&lt;N&gt;table_buffer</a></td><td>table, n</td></tr>

<tr><td align = right>static void</td><td><a href = "#fn:<N>table_clear">&lt;N&gt;table_clear</a></td><td>table</td></tr>

<tr><td align = right>static int</td><td><a href = "#fn:<N>table_is">&lt;N&gt;table_is</a></td><td>table, key</td></tr>

<tr><td align = right>static int</td><td><a href = "#fn:<N>table_query">&lt;N&gt;table_query</a></td><td>table, key, result</td></tr>

<tr><td align = right>static &lt;PN&gt;value</td><td><a href = "#fn:<N>table_get_or">&lt;N&gt;table_get_or</a></td><td>table, key, default_value</td></tr>

<tr><td align = right>static enum table_result</td><td><a href = "#fn:<N>table_try">&lt;N&gt;table_try</a></td><td>table, entry</td></tr>

<tr><td align = right>static enum table_result</td><td><a href = "#fn:<N>table_replace">&lt;N&gt;table_replace</a></td><td>table, entry, eject</td></tr>

<tr><td align = right>static enum table_result</td><td><a href = "#fn:<N>table_update">&lt;N&gt;table_update</a></td><td>table, entry, eject, policy</td></tr>

<tr><td align = right>static enum table_result</td><td><a href = "#fn:<N>table_compute">&lt;N&gt;table_compute</a></td><td>table, key, value</td></tr>

<tr><td align = right>static int</td><td><a href = "#fn:<N>table_remove">&lt;N&gt;table_remove</a></td><td>table, key</td></tr>

<tr><td align = right>static &lt;PITR&gt;element</td><td><a href = "#fn:<ITR>any">&lt;ITR&gt;any</a></td><td>box, predicate</td></tr>

<tr><td align = right>static void</td><td><a href = "#fn:<ITR>each">&lt;ITR&gt;each</a></td><td>box, action</td></tr>

<tr><td align = right>static void</td><td><a href = "#fn:<ITR>if_each">&lt;ITR&gt;if_each</a></td><td>box, predicate, action</td></tr>

<tr><td align = right>static int</td><td><a href = "#fn:<ITR>copy_if">&lt;ITR&gt;copy_if</a></td><td>dst, src, copy</td></tr>

<tr><td align = right>static void</td><td><a href = "#fn:<ITR>keep_if">&lt;ITR&gt;keep_if</a></td><td>box, keep, destruct</td></tr>

<tr><td align = right>static void</td><td><a href = "#fn:<ITR>trim">&lt;ITR&gt;trim</a></td><td>box, predicate</td></tr>

<tr><td align = right>static &lt;PN&gt;value</td><td><a href = "#fn:<N>table<D>get">&lt;N&gt;table&lt;D&gt;get</a></td><td>table, key</td></tr>

<tr><td align = right>static const char *</td><td><a href = "#fn:<STR>to_string">&lt;STR&gt;to_string</a></td><td>box</td></tr>

</table>

</div>

<div>

<h2><a id = "fn:" name = "fn:">Function Definitions</a></h2>

<div>

<h3><a id = "fn:<N>table" name = "fn:<N>table">&lt;N&gt;table</a></h3>

<p><code>static struct &lt;N&gt;table <strong>&lt;N&gt;table</strong>(void)</code></p>

<p>Zeroed data (not all-bits-zero) is initialized.</p>

<dl>
	<dt>Return:</dt>
	<dd>An idle array.</dd>
	<dt>Order:</dt>
	<dd>&#920;(1)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<N>table_" name = "fn:<N>table_">&lt;N&gt;table_</a></h3>

<p><code>static void <strong>&lt;N&gt;table_</strong>(struct &lt;N&gt;table *const <em>table</em>)</code></p>

<p>If <code>table</code> is not null, destroys and returns it to idle.</p>

</div>

<div>

<h3><a id = "fn:<N>table_begin" name = "fn:<N>table_begin">&lt;N&gt;table_begin</a></h3>

<p><code>static struct &lt;N&gt;table_iterator <strong>&lt;N&gt;table_begin</strong>(struct &lt;N&gt;table *const <em>table</em>)</code></p>

<p>Loads <code>table</code> (can be null) into <code>it</code>.</p>

</div>

<div>

<h3><a id = "fn:<N>table_next" name = "fn:<N>table_next">&lt;N&gt;table_next</a></h3>

<p><code>static int <strong>&lt;N&gt;table_next</strong>(struct &lt;N&gt;table_iterator *const <em>it</em>, &lt;PN&gt;entry *<em>entry</em>)</code></p>

<p>Advances <code>it</code>. The awkwardness of this function because <a href = "#typedef:&lt;PN&gt;entry">&lt;PN&gt;entry</a> is not necessarily nullifyable, so we are not guaranteed to have an out-of-band entry to indicate completion. (May be changed in the future.)</p>

<dl>
	<dt>Parameter: <em>entry</em></dt>
	<dd>If non-null, the entry is filled with the next element only if it has a next.</dd>
	<dt>Return:</dt>
	<dd>Whether it had a next element.</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<N>table_has_next" name = "fn:<N>table_has_next">&lt;N&gt;table_has_next</a></h3>

<p><code>static int <strong>&lt;N&gt;table_has_next</strong>(struct &lt;N&gt;table_iterator *const <em>it</em>)</code></p>

<p>Especially for tables that can have zero as a valid value, this is used to differentiate between zero and null.</p>

<dl>
	<dt>Return:</dt>
	<dd>Whether the table specified to <code>it</code> in <a href = "#fn:&lt;N&gt;table_begin">&lt;N&gt;table_begin</a> has a next element.</dd>
	<dt>Order:</dt>
	<dd>Amortized on the capacity, &#927;(1).</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<N>table_next_key" name = "fn:<N>table_next_key">&lt;N&gt;table_next_key</a></h3>

<p><code>static &lt;PN&gt;key <strong>&lt;N&gt;table_next_key</strong>(struct &lt;N&gt;table_iterator *const <em>it</em>)</code></p>

<p>Defined if <code>TABLE_VALUE</code>. Advances <code>it</code> only when <a href = "#fn:&lt;N&gt;table_has_next">&lt;N&gt;table_has_next</a>.</p>

<dl>
	<dt>Return:</dt>
	<dd>The next key.</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<N>table_next_value" name = "fn:<N>table_next_value">&lt;N&gt;table_next_value</a></h3>

<p><code>static &lt;PN&gt;value <strong>&lt;N&gt;table_next_value</strong>(struct &lt;N&gt;table_iterator *const <em>it</em>)</code></p>

<p>Defined if <code>TABLE_VALUE</code>. Advances <code>it</code> only when <a href = "#fn:&lt;N&gt;table_has_next">&lt;N&gt;table_has_next</a>.</p>

<dl>
	<dt>Return:</dt>
	<dd>The next value.</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<N>table_iterator_remove" name = "fn:<N>table_iterator_remove">&lt;N&gt;table_iterator_remove</a></h3>

<p><code>static int <strong>&lt;N&gt;table_iterator_remove</strong>(struct &lt;N&gt;table_iterator *const <em>it</em>)</code></p>

<p>Removes the entry at <code>it</code>. Whereas <a href = "#fn:&lt;N&gt;table_remove">&lt;N&gt;table_remove</a> invalidates the iterator, this corrects for a signal <code>it</code>.</p>

<dl>
	<dt>Return:</dt>
	<dd>Success, or there was no entry at the iterator's position, (anymore.)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<N>table_buffer" name = "fn:<N>table_buffer">&lt;N&gt;table_buffer</a></h3>

<p><code>static int <strong>&lt;N&gt;table_buffer</strong>(struct &lt;N&gt;table *const <em>table</em>, const &lt;PN&gt;uint <em>n</em>)</code></p>

<p>Reserve at least <code>n</code> more empty buckets in <code>table</code>. This may cause the capacity to increase and invalidates any pointers to data in the table.</p>

<dl>
	<dt>Return:</dt>
	<dd>Success.</dd>
	<dt>Exceptional return: ERANGE</dt>
	<dd>The request was unsatisfiable.</dd>
	<dt>Exceptional return: realloc</dt>
</dl>

</div>

<div>

<h3><a id = "fn:<N>table_clear" name = "fn:<N>table_clear">&lt;N&gt;table_clear</a></h3>

<p><code>static void <strong>&lt;N&gt;table_clear</strong>(struct &lt;N&gt;table *const <em>table</em>)</code></p>

<p>Clears and removes all buckets from <code>table</code>. The capacity and memory of the <code>table</code> is preserved, but all previous values are un-associated. (The load factor will be less until it reaches it's previous size.)</p>

<dl>
	<dt>Order:</dt>
	<dd>&#920;(<code>table.capacity</code>)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<N>table_is" name = "fn:<N>table_is">&lt;N&gt;table_is</a></h3>

<p><code>static int <strong>&lt;N&gt;table_is</strong>(struct &lt;N&gt;table *const <em>table</em>, const &lt;PN&gt;key <em>key</em>)</code></p>

<dl>
	<dt>Return:</dt>
	<dd>Whether <code>key</code> is in <code>table</code> (which can be null.)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<N>table_query" name = "fn:<N>table_query">&lt;N&gt;table_query</a></h3>

<p><code>static int <strong>&lt;N&gt;table_query</strong>(struct &lt;N&gt;table *const <em>table</em>, const &lt;PN&gt;key <em>key</em>, &lt;PN&gt;entry *<em>result</em>)</code></p>

<dl>
	<dt>Parameter: <em>result</em></dt>
	<dd>If null, behaves like <a href = "#fn:&lt;N&gt;table_is">&lt;N&gt;table_is</a>, otherwise, a <a href = "#typedef:&lt;PN&gt;entry">&lt;PN&gt;entry</a> which gets filled on true.</dd>
	<dt>Return:</dt>
	<dd>Whether <code>key</code> is in <code>table</code> (which can be null.)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<N>table_get_or" name = "fn:<N>table_get_or">&lt;N&gt;table_get_or</a></h3>

<p><code>static &lt;PN&gt;value <strong>&lt;N&gt;table_get_or</strong>(struct &lt;N&gt;table *const <em>table</em>, const &lt;PN&gt;key <em>key</em>, &lt;PN&gt;value <em>default_value</em>)</code></p>

<dl>
	<dt>Return:</dt>
	<dd>The value associated with <code>key</code> in <code>table</code>, (which can be null.) If no such value exists, <code>default_value</code> is returned.</dd>
	<dt>Order:</dt>
	<dd>Average &#927;(1); worst &#927;(n).</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<N>table_try" name = "fn:<N>table_try">&lt;N&gt;table_try</a></h3>

<p><code>static enum table_result <strong>&lt;N&gt;table_try</strong>(struct &lt;N&gt;table *const <em>table</em>, &lt;PN&gt;entry <em>entry</em>)</code></p>

<p>Puts <code>entry</code> in <code>table</code> only if absent.</p>

<dl>
	<dt>Return:</dt>
	<dd>One of: <code>TABLE_ERROR</code>, the table is not modified; <code>TABLE_YIELD</code>, not modified if there is another entry with the same key; <code>TABLE_UNIQUE</code>, put an entry in the table.</dd>
	<dt>Exceptional return: realloc, ERANGE</dt>
	<dd>On <code>TABLE_ERROR</code>.</dd>
	<dt>Order:</dt>
	<dd>Average amortised &#927;(1); worst &#927;(n).</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<N>table_replace" name = "fn:<N>table_replace">&lt;N&gt;table_replace</a></h3>

<p><code>static enum table_result <strong>&lt;N&gt;table_replace</strong>(struct &lt;N&gt;table *const <em>table</em>, &lt;PN&gt;entry <em>entry</em>, &lt;PN&gt;entry *<em>eject</em>)</code></p>

<p>Puts <code>entry</code> in <code>table</code>.</p>

<dl>
	<dt>Return:</dt>
	<dd>One of: <code>TABLE_ERROR</code>, the table is not modified; <code>TABLE_REPLACE</code>, the <code>entry</code> is put if the table, and, if non-null, <code>eject</code> will be filled; <code>TABLE_UNIQUE</code>, on a unique entry.</dd>
	<dt>Exceptional return: realloc, ERANGE</dt>
	<dd>On <code>TABLE_ERROR</code>.</dd>
	<dt>Order:</dt>
	<dd>Average amortised &#927;(1); worst &#927;(n).</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<N>table_update" name = "fn:<N>table_update">&lt;N&gt;table_update</a></h3>

<p><code>static enum table_result <strong>&lt;N&gt;table_update</strong>(struct &lt;N&gt;table *const <em>table</em>, &lt;PN&gt;entry <em>entry</em>, &lt;PN&gt;entry *<em>eject</em>, const &lt;PN&gt;policy_fn <em>policy</em>)</code></p>

<p>Puts <code>entry</code> in <code>table</code> only if absent or if calling <code>policy</code> returns true.</p>

<dl>
	<dt>Return:</dt>
	<dd>One of: <code>TABLE_ERROR</code>, the table is not modified; <code>TABLE_REPLACE</code>, if <code>update</code> is non-null and returns true, if non-null, <code>eject</code> will be filled; <code>TABLE_YIELD</code>, if <code>update</code> is null or false; <code>TABLE_UNIQUE</code>, on unique entry.</dd>
	<dt>Exceptional return: realloc, ERANGE</dt>
	<dd>On <code>TABLE_ERROR</code>.</dd>
	<dt>Order:</dt>
	<dd>Average amortised &#927;(1); worst &#927;(n).</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<N>table_compute" name = "fn:<N>table_compute">&lt;N&gt;table_compute</a></h3>

<p><code>static enum table_result <strong>&lt;N&gt;table_compute</strong>(struct &lt;N&gt;table *const <em>table</em>, &lt;PN&gt;key <em>key</em>, &lt;PN&gt;value **const <em>value</em>)</code></p>

<p>If <code>TABLE_VALUE</code> is defined. Try to put <code>key</code> into <code>table</code>, and store the associated value in a pointer <code>value</code>.</p>

<dl>
	<dt>Return:</dt>
	<dd><code>TABLE_ERROR</code> does not set <code>value</code>; <code>TABLE_GROW</code>, the <code>value</code> will point to uninitialized memory; <code>TABLE_YIELD</code>, gets the current <code>value</code> but doesn't use the <code>key</code>.</dd>
	<dt>Exceptional return: malloc, ERANGE</dt>
	<dd>On <code>TABLE_ERROR</code>.</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<N>table_remove" name = "fn:<N>table_remove">&lt;N&gt;table_remove</a></h3>

<p><code>static int <strong>&lt;N&gt;table_remove</strong>(struct &lt;N&gt;table *const <em>table</em>, const &lt;PN&gt;key <em>key</em>)</code></p>

<p>Removes <code>key</code> from <code>table</code> (which could be null.)</p>

<dl>
	<dt>Return:</dt>
	<dd>Whether that <code>key</code> was in <code>table</code>.</dd>
	<dt>Order:</dt>
	<dd>Average &#927;(1), (hash distributes elements uniformly); worst &#927;(n).</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<ITR>any" name = "fn:<ITR>any">&lt;ITR&gt;any</a></h3>

<p><code>static &lt;PITR&gt;element <strong>&lt;ITR&gt;any</strong>(&lt;PITR&gt;box *const <em>box</em>, const &lt;PITR&gt;predicate_fn <em>predicate</em>)</code></p>

<p><a href = "src/iterate.h">src/iterate.h</a>: Iterates through <code>box</code> and calls <code>predicate</code> until it returns true.</p>

<dl>
	<dt>Return:</dt>
	<dd>The first <code>predicate</code> that returned true, or, if the statement is false on all, null.</dd>
	<dt>Order:</dt>
	<dd>&#927;(<code>box.size</code>) &#215; &#927;(<code>predicate</code>)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<ITR>each" name = "fn:<ITR>each">&lt;ITR&gt;each</a></h3>

<p><code>static void <strong>&lt;ITR&gt;each</strong>(&lt;PITR&gt;box *const <em>box</em>, const &lt;PITR&gt;action_fn <em>action</em>)</code></p>

<p><a href = "src/iterate.h">src/iterate.h</a>: Iterates through <code>box</code> and calls <code>action</code> on all the elements.</p>

<dl>
	<dt>Order:</dt>
	<dd>&#927;(|<code>box</code>|) &#215; &#927;(<code>action</code>)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<ITR>if_each" name = "fn:<ITR>if_each">&lt;ITR&gt;if_each</a></h3>

<p><code>static void <strong>&lt;ITR&gt;if_each</strong>(&lt;PITR&gt;box *const <em>box</em>, const &lt;PITR&gt;predicate_fn <em>predicate</em>, const &lt;PITR&gt;action_fn <em>action</em>)</code></p>

<p><a href = "src/iterate.h">src/iterate.h</a>: Iterates through <code>box</code> and calls <code>action</code> on all the elements for which <code>predicate</code> returns true.</p>

<dl>
	<dt>Order:</dt>
	<dd>&#927;(<code>box.size</code>) &#215; (&#927;(<code>predicate</code>) + &#927;(<code>action</code>))</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<ITR>copy_if" name = "fn:<ITR>copy_if">&lt;ITR&gt;copy_if</a></h3>

<p><code>static int <strong>&lt;ITR&gt;copy_if</strong>(&lt;PITR&gt;box *restrict const <em>dst</em>, const &lt;PITR&gt;box *restrict const <em>src</em>, const &lt;PITR&gt;predicate_fn <em>copy</em>)</code></p>

<p><a href = "src/iterate.h">src/iterate.h</a>, <code>BOX_CONTIGUOUS</code>: For all elements of <code>src</code>, calls <code>copy</code>, and if true, lazily copies the elements to <code>dst</code>. <code>dst</code> and <code>src</code> can not be the same but <code>src</code> can be null, (in which case, it does nothing.)</p>

<dl>
	<dt>Exceptional return: realloc</dt>
	<dt>Order:</dt>
	<dd>&#927;(|<code>src</code>|) &#215; &#927;(<code>copy</code>)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<ITR>keep_if" name = "fn:<ITR>keep_if">&lt;ITR&gt;keep_if</a></h3>

<p><code>static void <strong>&lt;ITR&gt;keep_if</strong>(&lt;PITR&gt;box *const <em>box</em>, const &lt;PITR&gt;predicate_fn <em>keep</em>, const &lt;PITR&gt;action_fn <em>destruct</em>)</code></p>

<p><a href = "src/iterate.h">src/iterate.h</a>, <code>BOX_CONTIGUOUS</code>: For all elements of <code>box</code>, calls <code>keep</code>, and if false, lazy deletes that item. Calls <code>destruct</code> if not-null before deleting.</p>

<dl>
	<dt>Order:</dt>
	<dd>&#927;(|<code>box</code>|) (&#215; O(<code>keep</code>) + O(<code>destruct</code>))</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<ITR>trim" name = "fn:<ITR>trim">&lt;ITR&gt;trim</a></h3>

<p><code>static void <strong>&lt;ITR&gt;trim</strong>(&lt;PITR&gt;box *const <em>box</em>, const &lt;PITR&gt;predicate_fn <em>predicate</em>)</code></p>

<p><a href = "src/iterate.h">src/iterate.h</a>, <code>BOX_CONTIGUOUS</code>: Removes at either end of <code>box</code> the things that <code>predicate</code>, if it exists, returns true.</p>

<dl>
	<dt>Order:</dt>
	<dd>&#927;(<code>box.size</code>) &#215; &#927;(<code>predicate</code>)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<N>table<D>get" name = "fn:<N>table<D>get">&lt;N&gt;table&lt;D&gt;get</a></h3>

<p><code>static &lt;PN&gt;value <strong>&lt;N&gt;table&lt;D&gt;get</strong>(struct &lt;N&gt;table *const <em>table</em>, const &lt;PN&gt;key <em>key</em>)</code></p>

<p>This is functionally identical to <a href = "#fn:&lt;N&gt;table_get_or">&lt;N&gt;table_get_or</a>, but a with a trait specifying a constant default value.</p>

<dl>
	<dt>Return:</dt>
	<dd>The value associated with <code>key</code> in <code>table</code>, (which can be null.) If no such value exists, the <code>TABLE_DEFAULT</code> is returned.</dd>
	<dt>Order:</dt>
	<dd>Average &#927;(1); worst &#927;(n).</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<STR>to_string" name = "fn:<STR>to_string">&lt;STR&gt;to_string</a></h3>

<p><code>static const char *<strong>&lt;STR&gt;to_string</strong>(const &lt;PSTR&gt;box *const <em>box</em>)</code></p>

<p><a href = "src/to_string.h">src/to_string.h</a>: print the contents of <code>box</code> in a static string buffer of 256 bytes, with limitations of only printing 4 things at a time. <code>&lt;STR&gt;</code> is loosely contracted to be a name <code>&lt;X&gt;box[&lt;X_TO_STRING_NAME&gt;]</code>.</p>

<dl>
	<dt>Return:</dt>
	<dd>Address of the static buffer.</dd>
	<dt>Order:</dt>
	<dd>&#920;(1)</dd>
</dl>

</div>

</div>

<div>

<h2><a id = "license:" name = "license:">License</a></h2>

<p>2019 Neil Edelman, distributed under the terms of the <a href = "https://opensource.org/licenses/MIT">MIT License</a>.</p>

</div>

</body>

</html>
