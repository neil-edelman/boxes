<!doctype html public "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<html>

<head>
<meta http-equiv = "Content-Type" content = "text/html;charset=UTF-8">
<!-- Steal these colour values from JavaDocs. -->
<style type = "text/css">
	a:link,  a:visited { color: #4a6782; }
	a:hover, a:focus   { color: #bb7a2a; }
	a:active           { color: #4A6782; }
	tr:nth-child(even) { background: #dee3e9; }
	div {
		margin:  4px 0;
		padding: 0 4px 4px 4px;
	}
	table      { width: 100%; }
	td         { padding: 4px; }
	h3, h1 {
		color: #2c4557;
		background-color: #dee3e9;
		padding:          4px;
	}
	h3 {
		margin:           0 -4px;
		padding:          4px;
	}
</style>
<title>table.h</title>
</head>

<body>

<h1>table.h</h1>

<h2>Hash table</h2>

<ul>
	<li><a href = "#preamble:">Description</a></li>
	<li><a href = "#typedef:">Typedef Aliases</a>: <a href = "#typedef:<PN>uint">&lt;PN&gt;uint</a>, <a href = "#typedef:<PN>key">&lt;PN&gt;key</a>, <a href = "#typedef:<PN>ckey">&lt;PN&gt;ckey</a>, <a href = "#typedef:<PN>hash_fn">&lt;PN&gt;hash_fn</a>, <a href = "#typedef:<PN>inverse_hash_fn">&lt;PN&gt;inverse_hash_fn</a>, <a href = "#typedef:<PN>is_equal_fn">&lt;PN&gt;is_equal_fn</a>, <a href = "#typedef:<PN>value">&lt;PN&gt;value</a>, <a href = "#typedef:<PN>entry">&lt;PN&gt;entry</a>, <a href = "#typedef:<PN>policy_fn">&lt;PN&gt;policy_fn</a>, <a href = "#typedef:<PSZ>to_string_fn">&lt;PSZ&gt;to_string_fn</a></li>
	<li><a href = "#tag:">Struct, Union, and Enum Definitions</a>: <a href = "#tag:table_result">table_result</a>, <a href = "#tag:<N>table_entry">&lt;N&gt;table_entry</a>, <a href = "#tag:<N>table">&lt;N&gt;table</a>, <a href = "#tag:<N>table_iterator">&lt;N&gt;table_iterator</a></li>
	<li><a href = "#summary:">Function Summary</a></li>
	<li><a href = "#fn:">Function Definitions</a></li>
	<li><a href = "#license:">License</a></li>
</ul>

<div>

<h2><a id = "preamble:" name = "preamble:">Description</a></h2>

<p><img alt = "Example of &lt;string&gt;table." src = "web/table.png" width = 388 height = 391></p>

<p><a href = "#tag:&lt;N&gt;table">&lt;N&gt;table</a> implements a set or map of <a href = "#typedef:&lt;PN&gt;entry">&lt;PN&gt;entry</a> as a hash table. It must be supplied a <a href = "#typedef:&lt;PN&gt;hash_fn">&lt;PN&gt;hash_fn</a> and, <a href = "#typedef:&lt;PN&gt;is_equal_fn">&lt;PN&gt;is_equal_fn</a> or <a href = "#typedef:&lt;PN&gt;inverse_hash_fn">&lt;PN&gt;inverse_hash_fn</a>.</p>

</div>

<dl>
	<dt>Parameter: TABLE_NAME, TABLE_KEY</dt>
	<dd><code>&lt;N&gt;</code> that satisfies <code>C</code> naming conventions when mangled and a valid <a href = "#typedef:&lt;PN&gt;key">&lt;PN&gt;key</a> associated therewith; required. <code>&lt;PN&gt;</code> is private, whose names are prefixed in a manner to avoid collisions.</dd>
	<dt>Parameter: TABLE_HASH, TABLE_IS_EQUAL, TABLE_INVERSE</dt>
	<dd><code>TABLE_HASH</code>, and either <code>TABLE_IS_EQUAL</code> or <code>TABLE_INVERSE</code>, but not both, are required. Function satisfying <a href = "#typedef:&lt;PN&gt;hash_fn">&lt;PN&gt;hash_fn</a>, and <a href = "#typedef:&lt;PN&gt;is_equal_fn">&lt;PN&gt;is_equal_fn</a> or <a href = "#typedef:&lt;PN&gt;inverse_hash_fn">&lt;PN&gt;inverse_hash_fn</a>.</dd>
	<dt>Parameter: TABLE_VALUE</dt>
	<dd>An optional type that is the payload of the key, thus making this an associative array. If the key is part of an aggregate value, it will be more efficient and robust to use a type conversion instead of storing related pointers.</dd>
	<dt>Parameter: TABLE_UINT</dt>
	<dd>This is <a href = "#typedef:&lt;PN&gt;uint">&lt;PN&gt;uint</a>, the unsigned type of hash hash of the key given by <a href = "#typedef:&lt;PN&gt;hash_fn">&lt;PN&gt;hash_fn</a>; defaults to <code>size_t</code>.</dd>
	<dt>Parameter: TABLE_EXPECT_TRAIT</dt>
	<dd>Do not un-define certain variables for subsequent inclusion in a trait.</dd>
	<dt>Parameter: TABLE_DEFAULT_NAME, TABLE_DEFAULT</dt>
	<dd>Default trait; a name that satisfies <code>C</code> naming conventions when mangled and a <a href = "#typedef:&lt;PN&gt;value">&lt;PN&gt;value</a> used in <a href = "#fn:&lt;N&gt;table&lt;D&gt;get">&lt;N&gt;table&lt;D&gt;get</a>. There can be multiple defaults, but only one can omit <code>TABLE_DEFAULT_NAME</code>.</dd>
	<dt>Parameter: TABLE_TO_STRING_NAME, TABLE_TO_STRING</dt>
	<dd>To string trait contained in <a href = "to_string.h">to_string.h</a>; <code>&lt;SZ&gt;</code> that satisfies <code>C</code> naming conventions when mangled and function implementing <a href = "#typedef:&lt;PSZ&gt;to_string_fn">&lt;PSZ&gt;to_string_fn</a>. There can be multiple to string traits, but only one can omit <code>TABLE_TO_STRING_NAME</code>.</dd>
	<dt>Standard:</dt>
	<dd>C89</dd>
</dl>

<h2><a id = "typedef:" name = "typedef:">Typedef Aliases</a></h2>

<div>

<h3><a id = "typedef:<PN>uint" name = "typedef:<PN>uint">&lt;PN&gt;uint</a></h3>

<p><code>typedef TABLE_UINT <strong>&lt;PN&gt;uint</strong>;</code></p>

<p><a href = "#typedef:&lt;PN&gt;hash_fn">&lt;PN&gt;hash_fn</a> returns this hash type by <code>TABLE_UINT</code>, which must be be an unsigned integer. Places a simplifying limit on the maximum number of elements of half the cardinality.</p>

</div>

<div>

<h3><a id = "typedef:<PN>key" name = "typedef:<PN>key">&lt;PN&gt;key</a></h3>

<p><code>typedef TABLE_KEY <strong>&lt;PN&gt;key</strong>;</code></p>

<p>Valid tag type defined by <code>TABLE_KEY</code> used for keys. If <code>TABLE_INVERSE</code> is not defined, this will be part of the buckets.</p>

</div>

<div>

<h3><a id = "typedef:<PN>ckey" name = "typedef:<PN>ckey">&lt;PN&gt;ckey</a></h3>

<p><code>typedef const TABLE_KEY <strong>&lt;PN&gt;ckey</strong>;</code></p>

<p>Read-only <a href = "#typedef:&lt;PN&gt;key">&lt;PN&gt;key</a>. Makes the simplifying assumption that this is not <code>const</code>-qualified.</p>

</div>

<div>

<h3><a id = "typedef:<PN>hash_fn" name = "typedef:<PN>hash_fn">&lt;PN&gt;hash_fn</a></h3>

<p><code>typedef &lt;PN&gt;uint(*<strong>&lt;PN&gt;hash_fn</strong>)(&lt;PN&gt;ckey);</code></p>

<p>A map from <a href = "#typedef:&lt;PN&gt;ckey">&lt;PN&gt;ckey</a> onto <a href = "#typedef:&lt;PN&gt;uint">&lt;PN&gt;uint</a> that, ideally, should be easy to compute while minimizing duplicate addresses. Must be consistent for each value while in the table. If <a href = "#typedef:&lt;PN&gt;key">&lt;PN&gt;key</a> is a pointer, one is permitted to have null in the domain.</p>

</div>

<div>

<h3><a id = "typedef:<PN>inverse_hash_fn" name = "typedef:<PN>inverse_hash_fn">&lt;PN&gt;inverse_hash_fn</a></h3>

<p><code>typedef &lt;PN&gt;key(*<strong>&lt;PN&gt;inverse_hash_fn</strong>)(&lt;PN&gt;uint);</code></p>

<p>Defining <code>TABLE_INVERSE</code> says <a href = "#typedef:&lt;PN&gt;hash_fn">&lt;PN&gt;hash_fn</a> forms a bijection between the range in <a href = "#typedef:&lt;PN&gt;key">&lt;PN&gt;key</a> and the image in <a href = "#typedef:&lt;PN&gt;uint">&lt;PN&gt;uint</a>. The keys are not stored in the hash table at all, but rely on this, the inverse-mapping.</p>

</div>

<div>

<h3><a id = "typedef:<PN>is_equal_fn" name = "typedef:<PN>is_equal_fn">&lt;PN&gt;is_equal_fn</a></h3>

<p><code>typedef int(*<strong>&lt;PN&gt;is_equal_fn</strong>)(&lt;PN&gt;ckey a, &lt;PN&gt;ckey b);</code></p>

<p>Equivalence relation between <a href = "#typedef:&lt;PN&gt;key">&lt;PN&gt;key</a> that satisfies <code>&lt;PN&gt;is_equal_fn(a, b) -&gt; &lt;PN&gt;hash(a) == &lt;PN&gt;hash(b)</code>.</p>

</div>

<div>

<h3><a id = "typedef:<PN>value" name = "typedef:<PN>value">&lt;PN&gt;value</a></h3>

<p><code>typedef TABLE_VALUE <strong>&lt;PN&gt;value</strong>;</code></p>

<p>Defining <code>TABLE_VALUE</code> produces an associative map, otherwise it is the same as <a href = "#typedef:&lt;PN&gt;key">&lt;PN&gt;key</a>.</p>

</div>

<div>

<h3><a id = "typedef:<PN>entry" name = "typedef:<PN>entry">&lt;PN&gt;entry</a></h3>

<p><code>typedef struct &lt;N&gt;table_entry <strong>&lt;PN&gt;entry</strong>;</code></p>

<p>If <code>TABLE_VALUE</code>, this is <a href = "#tag:&lt;N&gt;table_entry">&lt;N&gt;table_entry</a>; otherwise, it's the same as <a href = "#typedef:&lt;PN&gt;key">&lt;PN&gt;key</a>.</p>

</div>

<div>

<h3><a id = "typedef:<PN>policy_fn" name = "typedef:<PN>policy_fn">&lt;PN&gt;policy_fn</a></h3>

<p><code>typedef int(*<strong>&lt;PN&gt;policy_fn</strong>)(&lt;PN&gt;key original, &lt;PN&gt;key replace);</code></p>

<p>Returns true if the <code>replace</code> replaces the <code>original</code>.</p>

</div>

<div>

<h3><a id = "typedef:<PSZ>to_string_fn" name = "typedef:<PSZ>to_string_fn">&lt;PSZ&gt;to_string_fn</a></h3>

<p><code>typedef void(*<strong>&lt;PSZ&gt;to_string_fn</strong>)(const &lt;PSZ&gt;type *, char(*)[12]);</code></p>

<p><a href = "to_string.h">to_string.h</a>: responsible for turning the argument into a 12-<code>char</code> null-terminated output string. <code>&lt;PSZ&gt;type</code> is contracted to be an internal iteration type of the box.</p>

</div>

<h2><a id = "tag:" name = "tag:">Struct, Union, and Enum Definitions</a></h2>

<div>

<h3><a id = "tag:table_result" name = "tag:table_result">table_result</a></h3>

<p><code>enum <strong>table_result</strong> { TABLE_RESULT };</code></p>

<p>This is the result of modifying the table, of which <code>TABLE_ERROR</code> is false. <img alt = "A diagram of the result states." src = "web/put.png" width = 657 height = 305></p>

</div>

<div>

<h3><a id = "tag:<N>table_entry" name = "tag:<N>table_entry">&lt;N&gt;table_entry</a></h3>

<p><code>struct <strong>&lt;N&gt;table_entry</strong> { &lt;PN&gt;key key; &lt;PN&gt;value value; };</code></p>

<p>Defining <code>TABLE_VALUE</code> creates this map from <a href = "#typedef:&lt;PN&gt;key">&lt;PN&gt;key</a> to <a href = "#typedef:&lt;PN&gt;value">&lt;PN&gt;value</a> as an interface with table. In general, reducing the size of these elements will be better for performance.</p>

</div>

<div>

<h3><a id = "tag:<N>table" name = "tag:<N>table">&lt;N&gt;table</a></h3>

<p><code>struct <strong>&lt;N&gt;table</strong> { struct &lt;PN&gt;bucket *buckets; &lt;PN&gt;uint log_capacity, size, top; };</code></p>

<p>To initialize, see <a href = "#fn:&lt;N&gt;table">&lt;N&gt;table</a>, <code>TABLE_IDLE</code>, <code>{0}</code> (<code>C99</code>,) or being <code>static</code>. The fields should be treated as read-only; any modification is liable to cause the table to go into an invalid state.</p>

<p><img alt = "States." src = "web/states.png" width = 808 height = 135></p>

</div>

<div>

<h3><a id = "tag:<N>table_iterator" name = "tag:<N>table_iterator">&lt;N&gt;table_iterator</a></h3>

<p><code>struct <strong>&lt;N&gt;table_iterator</strong>;</code></p>

<p><img alt = "States" src = "web/it.png" width = 1017 height = 121></p>

<p>Adding, deleting, successfully looking up entries, or any modification of the table's topology causes the iterator to become invalid. Use <a href = "#fn:&lt;N&gt;table_iterator_remove">&lt;N&gt;table_iterator_remove</a> to avoid this. For tables that can have zero as a valid value, <a href = "#fn:&lt;N&gt;table_has_next">&lt;N&gt;table_has_next</a> can differentiate between them. Iteration usually not in any particular order. The asymptotic runtime of iterating though the whole table is proportional to the capacity.</p>

</div>

<div>

<h2><a id = "summary:" name = "summary:">Function Summary</a></h2>

<table>

<tr><th>Modifiers</th><th>Function Name</th><th>Argument List</th></tr>

<tr><td align = right>static void</td><td><a href = "#fn:<N>table">&lt;N&gt;table</a></td><td>table</td></tr>

<tr><td align = right>static void</td><td><a href = "#fn:<N>table_">&lt;N&gt;table_</a></td><td>table</td></tr>

<tr><td align = right>static int</td><td><a href = "#fn:<N>table_buffer">&lt;N&gt;table_buffer</a></td><td>table, n</td></tr>

<tr><td align = right>static int</td><td><a href = "#fn:<N>table_shrink">&lt;N&gt;table_shrink</a></td><td>table</td></tr>

<tr><td align = right>static void</td><td><a href = "#fn:<N>table_clear">&lt;N&gt;table_clear</a></td><td>table</td></tr>

<tr><td align = right>static int</td><td><a href = "#fn:<N>table_is">&lt;N&gt;table_is</a></td><td>table, key</td></tr>

<tr><td align = right>static int</td><td><a href = "#fn:<N>table_query">&lt;N&gt;table_query</a></td><td>table, key, result</td></tr>

<tr><td align = right>static &lt;PN&gt;value</td><td><a href = "#fn:<N>table_get_or">&lt;N&gt;table_get_or</a></td><td>table, key, default_value</td></tr>

<tr><td align = right>static enum table_result</td><td><a href = "#fn:<N>table_try">&lt;N&gt;table_try</a></td><td>table, entry</td></tr>

<tr><td align = right>static enum table_result</td><td><a href = "#fn:<N>table_replace">&lt;N&gt;table_replace</a></td><td>table, entry, eject</td></tr>

<tr><td align = right>static enum table_result</td><td><a href = "#fn:<N>table_update">&lt;N&gt;table_update</a></td><td>table, entry, eject, update</td></tr>

<tr><td align = right>static enum table_result</td><td><a href = "#fn:<N>table_compute">&lt;N&gt;table_compute</a></td><td>table, key, value</td></tr>

<tr><td align = right>static int</td><td><a href = "#fn:<N>table_remove">&lt;N&gt;table_remove</a></td><td>table, key</td></tr>

<tr><td align = right>static void</td><td><a href = "#fn:<N>table_begin">&lt;N&gt;table_begin</a></td><td>it, table</td></tr>

<tr><td align = right>static int</td><td><a href = "#fn:<N>table_next">&lt;N&gt;table_next</a></td><td>it, entry</td></tr>

<tr><td align = right>static int</td><td><a href = "#fn:<N>table_has_next">&lt;N&gt;table_has_next</a></td><td>it</td></tr>

<tr><td align = right>static &lt;PN&gt;key</td><td><a href = "#fn:<N>table_next_key">&lt;N&gt;table_next_key</a></td><td>it</td></tr>

<tr><td align = right>static &lt;PN&gt;value</td><td><a href = "#fn:<N>table_next_value">&lt;N&gt;table_next_value</a></td><td>it</td></tr>

<tr><td align = right>static int</td><td><a href = "#fn:<N>table_iterator_remove">&lt;N&gt;table_iterator_remove</a></td><td>it</td></tr>

<tr><td align = right>static &lt;PN&gt;value</td><td><a href = "#fn:<N>table<D>get">&lt;N&gt;table&lt;D&gt;get</a></td><td>table, key</td></tr>

<tr><td align = right>static const char *</td><td><a href = "#fn:<SZ>to_string">&lt;SZ&gt;to_string</a></td><td>box</td></tr>

</table>

</div>

<div>

<h2><a id = "fn:" name = "fn:">Function Definitions</a></h2>

<div>

<h3><a id = "fn:<N>table" name = "fn:<N>table">&lt;N&gt;table</a></h3>

<p><code>static void <strong>&lt;N&gt;table</strong>(struct &lt;N&gt;table *const <em>table</em>)</code></p>

<p>Initialises <code>table</code> to idle.</p>

<dl>
	<dt>Order:</dt>
	<dd>&#920;(1)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<N>table_" name = "fn:<N>table_">&lt;N&gt;table_</a></h3>

<p><code>static void <strong>&lt;N&gt;table_</strong>(struct &lt;N&gt;table *const <em>table</em>)</code></p>

<p>Destroys <code>table</code> and returns it to idle.</p>

</div>

<div>

<h3><a id = "fn:<N>table_buffer" name = "fn:<N>table_buffer">&lt;N&gt;table_buffer</a></h3>

<p><code>static int <strong>&lt;N&gt;table_buffer</strong>(struct &lt;N&gt;table *const <em>table</em>, const &lt;PN&gt;uint <em>n</em>)</code></p>

<p>Reserve at least <code>n</code> more empty buckets in <code>table</code>. This may cause the capacity to increase.</p>

<dl>
	<dt>Return:</dt>
	<dd>Success.</dd>
	<dt>Exceptional return: ERANGE</dt>
	<dd>The request was unsatisfiable.</dd>
	<dt>Exceptional return: realloc</dt>
</dl>

</div>

<div>

<h3><a id = "fn:<N>table_shrink" name = "fn:<N>table_shrink">&lt;N&gt;table_shrink</a></h3>

<p><code>static int <strong>&lt;N&gt;table_shrink</strong>(struct &lt;N&gt;table *const <em>table</em>)</code></p>

<p>Will re-size <code>table</code> to the power-of-two (above 2) that will fit all the keys. If it is idle, than it remains idle.</p>

<dl>
	<dt>Return:</dt>
	<dd>Always returns zero because this is not implemented.</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<N>table_clear" name = "fn:<N>table_clear">&lt;N&gt;table_clear</a></h3>

<p><code>static void <strong>&lt;N&gt;table_clear</strong>(struct &lt;N&gt;table *const <em>table</em>)</code></p>

<p>Clears and removes all buckets from <code>table</code>. The capacity and memory of the <code>table</code> is preserved, but all previous values are un-associated. (The load factor will be less until it reaches it's previous size.)</p>

<dl>
	<dt>Order:</dt>
	<dd>&#920;(<code>table.capacity</code>)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<N>table_is" name = "fn:<N>table_is">&lt;N&gt;table_is</a></h3>

<p><code>static int <strong>&lt;N&gt;table_is</strong>(struct &lt;N&gt;table *const <em>table</em>, const &lt;PN&gt;key <em>key</em>)</code></p>

<dl>
	<dt>Return:</dt>
	<dd>Whether <code>key</code> is in <code>table</code> (which can be null.)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<N>table_query" name = "fn:<N>table_query">&lt;N&gt;table_query</a></h3>

<p><code>static int <strong>&lt;N&gt;table_query</strong>(struct &lt;N&gt;table *const <em>table</em>, const &lt;PN&gt;key <em>key</em>, &lt;PN&gt;entry *const <em>result</em>)</code></p>

<dl>
	<dt>Parameter: <em>result</em></dt>
	<dd>If null, behaves like <a href = "#fn:&lt;N&gt;table_is">&lt;N&gt;table_is</a>, otherwise, a <a href = "#typedef:&lt;PN&gt;entry">&lt;PN&gt;entry</a> which gets filled on true.</dd>
	<dt>Return:</dt>
	<dd>Whether <code>key</code> is in <code>table</code> (which can be null.)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<N>table_get_or" name = "fn:<N>table_get_or">&lt;N&gt;table_get_or</a></h3>

<p><code>static &lt;PN&gt;value <strong>&lt;N&gt;table_get_or</strong>(struct &lt;N&gt;table *const <em>table</em>, const &lt;PN&gt;key <em>key</em>, &lt;PN&gt;value <em>default_value</em>)</code></p>

<dl>
	<dt>Return:</dt>
	<dd>The value associated with <code>key</code> in <code>table</code>, (which can be null.) If no such value exists, <code>default_value</code> is returned.</dd>
	<dt>Order:</dt>
	<dd>Average &#927;(1); worst &#927;(n).</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<N>table_try" name = "fn:<N>table_try">&lt;N&gt;table_try</a></h3>

<p><code>static enum table_result <strong>&lt;N&gt;table_try</strong>(struct &lt;N&gt;table *const <em>table</em>, &lt;PN&gt;entry <em>entry</em>)</code></p>

<p>Puts <code>entry</code> in <code>table</code> only if absent.</p>

<dl>
	<dt>Return:</dt>
	<dd>One of: <code>TABLE_ERROR</code>, the table is not modified; <code>TABLE_YIELD</code>, not modified if there is another entry with the same key; <code>TABLE_UNIQUE</code>, put an entry in the table.</dd>
	<dt>Exceptional return: realloc, ERANGE</dt>
	<dd>On <code>TABLE_ERROR</code>.</dd>
	<dt>Order:</dt>
	<dd>Average amortised &#927;(1); worst &#927;(n).</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<N>table_replace" name = "fn:<N>table_replace">&lt;N&gt;table_replace</a></h3>

<p><code>static enum table_result <strong>&lt;N&gt;table_replace</strong>(struct &lt;N&gt;table *const <em>table</em>, &lt;PN&gt;entry <em>entry</em>, &lt;PN&gt;entry *<em>eject</em>)</code></p>

<p>Puts <code>entry</code> in <code>table</code>.</p>

<dl>
	<dt>Return:</dt>
	<dd>One of: <code>TABLE_ERROR</code>, the table is not modified; <code>TABLE_REPLACE</code>, the <code>entry</code> is put if the table, and, if non-null, <code>eject</code> will be filled; <code>TABLE_UNIQUE</code>, on a unique entry.</dd>
	<dt>Exceptional return: realloc, ERANGE</dt>
	<dd>On <code>TABLE_ERROR</code>.</dd>
	<dt>Order:</dt>
	<dd>Average amortised &#927;(1); worst &#927;(n).</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<N>table_update" name = "fn:<N>table_update">&lt;N&gt;table_update</a></h3>

<p><code>static enum table_result <strong>&lt;N&gt;table_update</strong>(struct &lt;N&gt;table *const <em>table</em>, &lt;PN&gt;entry <em>entry</em>, &lt;PN&gt;entry *<em>eject</em>, const &lt;PN&gt;policy_fn <em>update</em>)</code></p>

<p>Puts <code>entry</code> in <code>table</code> only if absent or if calling <code>update</code> returns true.</p>

<dl>
	<dt>Return:</dt>
	<dd>One of: <code>TABLE_ERROR</code>, the table is not modified; <code>TABLE_REPLACE</code>, if <code>update</code> is non-null and returns true, if non-null, <code>eject</code> will be filled; <code>TABLE_YIELD</code>, if <code>update</code> is null or false; <code>TABLE_UNIQUE</code>, on unique entry.</dd>
	<dt>Exceptional return: realloc, ERANGE</dt>
	<dd>On <code>TABLE_ERROR</code>.</dd>
	<dt>Order:</dt>
	<dd>Average amortised &#927;(1); worst &#927;(n).</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<N>table_compute" name = "fn:<N>table_compute">&lt;N&gt;table_compute</a></h3>

<p><code>static enum table_result <strong>&lt;N&gt;table_compute</strong>(struct &lt;N&gt;table *const <em>table</em>, &lt;PN&gt;key <em>key</em>, &lt;PN&gt;value **const <em>value</em>)</code></p>

<p>If <code>TABLE_VALUE</code> is defined. Try to put <code>key</code> into <code>table</code>, and store the associated value in a pointer <code>value</code>.</p>

<dl>
	<dt>Return:</dt>
	<dd><code>TABLE_ERROR</code> does not set <code>value</code>; <code>TABLE_GROW</code>, the <code>value</code> will point to uninitialized memory; <code>TABLE_YIELD</code>, gets the current <code>value</code> but doesn't use the <code>key</code>.</dd>
	<dt>Exceptional return: malloc, ERANGE</dt>
	<dd>On <code>TABLE_ERROR</code>.</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<N>table_remove" name = "fn:<N>table_remove">&lt;N&gt;table_remove</a></h3>

<p><code>static int <strong>&lt;N&gt;table_remove</strong>(struct &lt;N&gt;table *const <em>table</em>, const &lt;PN&gt;key <em>key</em>)</code></p>

<p>Removes <code>key</code> from <code>table</code> (which could be null.)</p>

<dl>
	<dt>Return:</dt>
	<dd>Whether that <code>key</code> was in <code>table</code>.</dd>
	<dt>Order:</dt>
	<dd>Average &#927;(1), (hash distributes elements uniformly); worst &#927;(n).</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<N>table_begin" name = "fn:<N>table_begin">&lt;N&gt;table_begin</a></h3>

<p><code>static void <strong>&lt;N&gt;table_begin</strong>(struct &lt;N&gt;table_iterator *const <em>it</em>, struct &lt;N&gt;table *const <em>table</em>)</code></p>

<p>Loads <code>table</code> (can be null) into <code>it</code>.</p>

</div>

<div>

<h3><a id = "fn:<N>table_next" name = "fn:<N>table_next">&lt;N&gt;table_next</a></h3>

<p><code>static int <strong>&lt;N&gt;table_next</strong>(struct &lt;N&gt;table_iterator *const <em>it</em>, &lt;PN&gt;entry *<em>entry</em>)</code></p>

<p>Advances <code>it</code>.</p>

<dl>
	<dt>Parameter: <em>entry</em></dt>
	<dd>If non-null, the entry is filled with the next element only if it has a next.</dd>
	<dt>Return:</dt>
	<dd>Whether it had a next element.</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<N>table_has_next" name = "fn:<N>table_has_next">&lt;N&gt;table_has_next</a></h3>

<p><code>static int <strong>&lt;N&gt;table_has_next</strong>(struct &lt;N&gt;table_iterator *const <em>it</em>)</code></p>

<dl>
	<dt>Return:</dt>
	<dd>Whether the table specified to <code>it</code> in <a href = "#fn:&lt;N&gt;table_begin">&lt;N&gt;table_begin</a> has a next element.</dd>
	<dt>Order:</dt>
	<dd>Amortized on the capacity, &#927;(1).</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<N>table_next_key" name = "fn:<N>table_next_key">&lt;N&gt;table_next_key</a></h3>

<p><code>static &lt;PN&gt;key <strong>&lt;N&gt;table_next_key</strong>(struct &lt;N&gt;table_iterator *const <em>it</em>)</code></p>

<p>If <code>TABLE_VALUE</code>, advances <code>it</code> when <a href = "#fn:&lt;N&gt;table_has_next">&lt;N&gt;table_has_next</a>.</p>

<dl>
	<dt>Return:</dt>
	<dd>The next key.</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<N>table_next_value" name = "fn:<N>table_next_value">&lt;N&gt;table_next_value</a></h3>

<p><code>static &lt;PN&gt;value <strong>&lt;N&gt;table_next_value</strong>(struct &lt;N&gt;table_iterator *const <em>it</em>)</code></p>

<p>If <code>TABLE_VALUE</code>, advances <code>it</code> when <a href = "#fn:&lt;N&gt;table_has_next">&lt;N&gt;table_has_next</a>.</p>

<dl>
	<dt>Return:</dt>
	<dd>The next value.</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<N>table_iterator_remove" name = "fn:<N>table_iterator_remove">&lt;N&gt;table_iterator_remove</a></h3>

<p><code>static int <strong>&lt;N&gt;table_iterator_remove</strong>(struct &lt;N&gt;table_iterator *const <em>it</em>)</code></p>

<p><a href = "#fn:&lt;N&gt;table_remove">&lt;N&gt;table_remove</a> invalidates the iterator because , but Removes the entry at <code>it</code>.</p>

<dl>
	<dt>Return:</dt>
	<dd>Success, or there was no entry at the iterator's position (anymore).</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<N>table<D>get" name = "fn:<N>table<D>get">&lt;N&gt;table&lt;D&gt;get</a></h3>

<p><code>static &lt;PN&gt;value <strong>&lt;N&gt;table&lt;D&gt;get</strong>(struct &lt;N&gt;table *const <em>table</em>, const &lt;PN&gt;key <em>key</em>)</code></p>

<p>This is functionally identical to <a href = "#fn:&lt;N&gt;table_get_or">&lt;N&gt;table_get_or</a>, but a with a trait specifying a constant default value.</p>

<dl>
	<dt>Return:</dt>
	<dd>The value associated with <code>key</code> in <code>table</code>, (which can be null.) If no such value exists, the <code>TABLE_DEFAULT</code> is returned.</dd>
	<dt>Order:</dt>
	<dd>Average &#927;(1); worst &#927;(n).</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<SZ>to_string" name = "fn:<SZ>to_string">&lt;SZ&gt;to_string</a></h3>

<p><code>static const char *<strong>&lt;SZ&gt;to_string</strong>(const &lt;PSZ&gt;box *const <em>box</em>)</code></p>

<p><a href = "to_string.h">to_string.h</a>: print the contents of <code>box</code> in a static string buffer of 256 bytes, with limitations of only printing 4 things at a time. <code>&lt;PSZ&gt;box</code> is contracted to be the box itself. <code>&lt;SZ&gt;</code> is loosely contracted to be a name <code>&lt;X&gt;box[&lt;X_TO_STRING_NAME&gt;]</code>.</p>

<dl>
	<dt>Return:</dt>
	<dd>Address of the static buffer.</dd>
	<dt>Order:</dt>
	<dd>&#920;(1)</dd>
</dl>

</div>

</div>

<div>

<h2><a id = "license:" name = "license:">License</a></h2>

<p>2019 Neil Edelman, distributed under the terms of the <a href = "https://opensource.org/licenses/MIT">MIT License</a>.</p>

</div>

</body>

</html>
