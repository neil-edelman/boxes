<!doctype html public "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<html>

<head>
<meta http-equiv = "Content-Type" content = "text/html;charset=UTF-8">
<!-- Steal these colour values from JavaDocs. -->
<style type = "text/css">
	a:link,  a:visited { color: #4a6782; }
	a:hover, a:focus   { color: #bb7a2a; }
	a:active           { color: #4A6782; }
	tr:nth-child(even) { background: #dee3e9; }
	div {
		margin:  4px 0;
		padding: 0 4px 4px 4px;
	}
	table      { width: 100%; }
	td         { padding: 4px; }
	h3, h1 {
		color: #2c4557;
		background-color: #dee3e9;
		padding:          4px;
	}
	h3 {
		margin:           0 -4px;
		padding:          4px;
	}
</style>
<title>array.h</title>
</head>

<body>

<h1>array.h</h1>

<p>Source <a href = "src/array.h">src/array.h</a>; examples <a href = "test/test_array.c">test/test_array.c</a>.</p>

<h2>Contiguous dynamic array</h2>

<ul>
	<li><a href = "#preamble:">Description</a></li>
	<li><a href = "#typedef:">Typedef Aliases</a>: <a href = "#typedef:<PA>type">&lt;PA&gt;type</a>, <a href = "#typedef:<PAC>box">&lt;PAC&gt;box</a>, <a href = "#typedef:<PAC>type">&lt;PAC&gt;type</a>, <a href = "#typedef:<PAC>action_fn">&lt;PAC&gt;action_fn</a>, <a href = "#typedef:<PAC>predicate_fn">&lt;PAC&gt;predicate_fn</a>, <a href = "#typedef:<PAC>bipredicate_fn">&lt;PAC&gt;bipredicate_fn</a>, <a href = "#typedef:<PAC>compare_fn">&lt;PAC&gt;compare_fn</a>, <a href = "#typedef:<PAC>biaction_fn">&lt;PAC&gt;biaction_fn</a>, <a href = "#typedef:<PSZ>to_string_fn">&lt;PSZ&gt;to_string_fn</a></li>
	<li><a href = "#tag:">Struct, Union, and Enum Definitions</a>: <a href = "#tag:<A>array">&lt;A&gt;array</a></li>
	<li><a href = "#summary:">Function Summary</a></li>
	<li><a href = "#fn:">Function Definitions</a></li>
	<li><a href = "#license:">License</a></li>
</ul>

<div>

<h2><a id = "preamble:" name = "preamble:">Description</a></h2>

<p><img alt = "Example of array." src = "doc/array.png" width = 428 height = 301></p>

<p><a href = "#tag:&lt;A&gt;array">&lt;A&gt;array</a> is a dynamic array that stores contiguous <a href = "#typedef:&lt;PA&gt;type">&lt;PA&gt;type</a>. Resizing may be necessary when increasing the size of the array; this incurs amortised cost, and any pointers to this memory may become stale.</p>

</div>

<dl>
	<dt>Parameter: ARRAY_NAME, ARRAY_TYPE</dt>
	<dd><code>&lt;A&gt;</code> that satisfies <code>C</code> naming conventions when mangled and a valid tag-type, <a href = "#typedef:&lt;PA&gt;type">&lt;PA&gt;type</a>, associated therewith; required. <code>&lt;PA&gt;</code> is private, whose names are prefixed in a manner to avoid collisions.</dd>
	<dt>Parameter: ARRAY_CODA</dt>
	<dd>Include more functions contained in <a href = "src/array_coda.h">src/array_coda.h</a>, where <code>&lt;AC&gt;</code> is <code>&lt;A&gt;array</code>.</dd>
	<dt>Parameter: ARRAY_MIN_CAPACITY</dt>
	<dd>Default is 3; optional number in <code>[2, SIZE_MAX]</code> that the capacity can not go below.</dd>
	<dt>Parameter: ARRAY_EXPECT_TRAIT</dt>
	<dd>Do not un-define certain variables for subsequent inclusion in a parameterized trait.</dd>
	<dt>Parameter: ARRAY_COMPARE_NAME, ARRAY_COMPARE, ARRAY_IS_EQUAL</dt>
	<dd>Compare trait contained in <a href = "src/array_coda.h">src/array_coda.h</a>. An optional mangled name for uniqueness and a function implementing either <a href = "#typedef:&lt;PAC&gt;compare_fn">&lt;PAC&gt;compare_fn</a> or <a href = "#typedef:&lt;PAC&gt;bipredicate_fn">&lt;PAC&gt;bipredicate_fn</a>.</dd>
	<dt>Parameter: ARRAY_TO_STRING_NAME, ARRAY_TO_STRING</dt>
	<dd>To string trait contained in <a href = "src/to_string.h">src/to_string.h</a>. An optional mangled name for uniqueness and function implementing <a href = "#typedef:&lt;PSZ&gt;to_string_fn">&lt;PSZ&gt;to_string_fn</a>.</dd>
	<dt>Standard:</dt>
	<dd>C89</dd>
</dl>

<h2><a id = "typedef:" name = "typedef:">Typedef Aliases</a></h2>

<div>

<h3><a id = "typedef:<PA>type" name = "typedef:<PA>type">&lt;PA&gt;type</a></h3>

<p><code>typedef ARRAY_TYPE <strong>&lt;PA&gt;type</strong>;</code></p>

<p>A valid tag type set by <code>ARRAY_TYPE</code>.</p>

</div>

<div>

<h3><a id = "typedef:<PAC>box" name = "typedef:<PAC>box">&lt;PAC&gt;box</a></h3>

<p><code>typedef BOX_CONTAINER <strong>&lt;PAC&gt;box</strong>;</code></p>

<p><a href = "src/array_coda.h">src/array_coda.h</a>: an alias to the box.</p>

</div>

<div>

<h3><a id = "typedef:<PAC>type" name = "typedef:<PAC>type">&lt;PAC&gt;type</a></h3>

<p><code>typedef BOX_CONTENTS <strong>&lt;PAC&gt;type</strong>;</code></p>

<p><a href = "src/array_coda.h">src/array_coda.h</a>: an alias to the individual type contained in the box.</p>

</div>

<div>

<h3><a id = "typedef:<PAC>action_fn" name = "typedef:<PAC>action_fn">&lt;PAC&gt;action_fn</a></h3>

<p><code>typedef void(*<strong>&lt;PAC&gt;action_fn</strong>)(&lt;PAC&gt;type *);</code></p>

<p><a href = "src/array_coda.h">src/array_coda.h</a>: Operates by side-effects on <a href = "#typedef:&lt;PAC&gt;type">&lt;PAC&gt;type</a>.</p>

</div>

<div>

<h3><a id = "typedef:<PAC>predicate_fn" name = "typedef:<PAC>predicate_fn">&lt;PAC&gt;predicate_fn</a></h3>

<p><code>typedef int(*<strong>&lt;PAC&gt;predicate_fn</strong>)(const &lt;PAC&gt;type *);</code></p>

<p><a href = "src/array_coda.h">src/array_coda.h</a>: Returns a boolean given read-only <a href = "#typedef:&lt;PAC&gt;type">&lt;PAC&gt;type</a>.</p>

</div>

<div>

<h3><a id = "typedef:<PAC>bipredicate_fn" name = "typedef:<PAC>bipredicate_fn">&lt;PAC&gt;bipredicate_fn</a></h3>

<p><code>typedef int(*<strong>&lt;PAC&gt;bipredicate_fn</strong>)(const &lt;PAC&gt;type *, const &lt;PAC&gt;type *);</code></p>

<p><a href = "src/array_coda.h">src/array_coda.h</a>: Returns a boolean given two read-only <a href = "#typedef:&lt;PAC&gt;type">&lt;PAC&gt;type</a>.</p>

</div>

<div>

<h3><a id = "typedef:<PAC>compare_fn" name = "typedef:<PAC>compare_fn">&lt;PAC&gt;compare_fn</a></h3>

<p><code>typedef int(*<strong>&lt;PAC&gt;compare_fn</strong>)(const &lt;PAC&gt;type *a, const &lt;PAC&gt;type *b);</code></p>

<p><a href = "src/array_coda.h">src/array_coda.h</a>: Three-way comparison on a totally order set of <a href = "#typedef:&lt;PAC&gt;type">&lt;PAC&gt;type</a>; returns an integer value less then, equal to, greater then zero, if <code>a &lt; b</code>, <code>a == b</code>, <code>a &gt; b</code>, respectively.</p>

</div>

<div>

<h3><a id = "typedef:<PAC>biaction_fn" name = "typedef:<PAC>biaction_fn">&lt;PAC&gt;biaction_fn</a></h3>

<p><code>typedef int(*<strong>&lt;PAC&gt;biaction_fn</strong>)(&lt;PAC&gt;type *, &lt;PAC&gt;type *);</code></p>

<p><a href = "src/array_coda.h">src/array_coda.h</a>: Returns a boolean given two <a href = "#typedef:&lt;PAC&gt;type">&lt;PAC&gt;type</a>.</p>

</div>

<div>

<h3><a id = "typedef:<PSZ>to_string_fn" name = "typedef:<PSZ>to_string_fn">&lt;PSZ&gt;to_string_fn</a></h3>

<p><code>typedef void(*<strong>&lt;PSZ&gt;to_string_fn</strong>)(const &lt;PSZ&gt;type *, char(*)[12]);</code></p>

<p><a href = "to_string.h">to_string.h</a>: responsible for turning the argument into a 12-<code>char</code> null-terminated output string. <code>&lt;PSZ&gt;type</code> is contracted to be an internal iteration type of the box.</p>

</div>

<h2><a id = "tag:" name = "tag:">Struct, Union, and Enum Definitions</a></h2>

<div>

<h3><a id = "tag:<A>array" name = "tag:<A>array">&lt;A&gt;array</a></h3>

<p><code>struct <strong>&lt;A&gt;array</strong> { &lt;PA&gt;type *data; size_t size, capacity; };</code></p>

<p>Manages the array field <code>data</code> which has <code>size</code> elements. The space is indexed up to <code>capacity</code>, which is at least <code>size</code>. To initialize it to an idle state, see <a href = "#fn:&lt;A&gt;array">&lt;A&gt;array</a>, <code>ARRAY_IDLE</code>, <code>{0}</code> (<code>C99</code>,) or being <code>static</code>. The fields should be treated as read-only; any modification is liable to cause the array to go into an invalid state.</p>

<p><img alt = "States." src = "doc/states.png" width = 901 height = 137></p>

</div>

<div>

<h2><a id = "summary:" name = "summary:">Function Summary</a></h2>

<table>

<tr><th>Modifiers</th><th>Function Name</th><th>Argument List</th></tr>

<tr><td align = right>static void</td><td><a href = "#fn:<A>array">&lt;A&gt;array</a></td><td>a</td></tr>

<tr><td align = right>static void</td><td><a href = "#fn:<A>array_">&lt;A&gt;array_</a></td><td>a</td></tr>

<tr><td align = right>static int</td><td><a href = "#fn:<A>array_reserve">&lt;A&gt;array_reserve</a></td><td>a, min</td></tr>

<tr><td align = right>static &lt;PA&gt;type *</td><td><a href = "#fn:<A>array_buffer">&lt;A&gt;array_buffer</a></td><td>a, n</td></tr>

<tr><td align = right>static &lt;PA&gt;type *</td><td><a href = "#fn:<A>array_insert">&lt;A&gt;array_insert</a></td><td>a, n, at</td></tr>

<tr><td align = right>static &lt;PA&gt;type *</td><td><a href = "#fn:<A>array_new">&lt;A&gt;array_new</a></td><td>a</td></tr>

<tr><td align = right>static void</td><td><a href = "#fn:<A>array_remove">&lt;A&gt;array_remove</a></td><td>a, datum</td></tr>

<tr><td align = right>static void</td><td><a href = "#fn:<A>array_lazy_remove">&lt;A&gt;array_lazy_remove</a></td><td>a, datum</td></tr>

<tr><td align = right>static void</td><td><a href = "#fn:<A>array_clear">&lt;A&gt;array_clear</a></td><td>a</td></tr>

<tr><td align = right>static &lt;PA&gt;type *</td><td><a href = "#fn:<A>array_peek">&lt;A&gt;array_peek</a></td><td>a</td></tr>

<tr><td align = right>static &lt;PA&gt;type *</td><td><a href = "#fn:<A>array_pop">&lt;A&gt;array_pop</a></td><td>a</td></tr>

<tr><td align = right>static &lt;PA&gt;type *</td><td><a href = "#fn:<A>array_append">&lt;A&gt;array_append</a></td><td>a, n</td></tr>

<tr><td align = right>static int</td><td><a href = "#fn:<A>array_splice">&lt;A&gt;array_splice</a></td><td>a, b, i0, i1</td></tr>

<tr><td align = right>static &lt;PAC&gt;type *</td><td><a href = "#fn:<AC>previous">&lt;AC&gt;previous</a></td><td>box, x</td></tr>

<tr><td align = right>static &lt;PAC&gt;type *</td><td><a href = "#fn:<AC>next">&lt;AC&gt;next</a></td><td>box, x</td></tr>

<tr><td align = right>static size_t</td><td><a href = "#fn:<AC>clip">&lt;AC&gt;clip</a></td><td>box, i</td></tr>

<tr><td align = right>static int</td><td><a href = "#fn:<AC>copy_if">&lt;AC&gt;copy_if</a></td><td>a, copy, b</td></tr>

<tr><td align = right>static void</td><td><a href = "#fn:<AC>keep_if">&lt;AC&gt;keep_if</a></td><td>box, keep, destruct</td></tr>

<tr><td align = right>static void</td><td><a href = "#fn:<AC>trim">&lt;AC&gt;trim</a></td><td>box, predicate</td></tr>

<tr><td align = right>static void</td><td><a href = "#fn:<AC>each">&lt;AC&gt;each</a></td><td>box, action</td></tr>

<tr><td align = right>static void</td><td><a href = "#fn:<AC>if_each">&lt;AC&gt;if_each</a></td><td>box, predicate, action</td></tr>

<tr><td align = right>static const &lt;PAC&gt;type *</td><td><a href = "#fn:<AC>any">&lt;AC&gt;any</a></td><td>box, predicate</td></tr>

<tr><td align = right>static int</td><td><a href = "#fn:<ACC>compare">&lt;ACC&gt;compare</a></td><td>a, b</td></tr>

<tr><td align = right>static size_t</td><td><a href = "#fn:<ACC>lower_bound">&lt;ACC&gt;lower_bound</a></td><td>box, value</td></tr>

<tr><td align = right>static size_t</td><td><a href = "#fn:<ACC>upper_bound">&lt;ACC&gt;upper_bound</a></td><td>box, value</td></tr>

<tr><td align = right>static int</td><td><a href = "#fn:<ACC>insert_after">&lt;ACC&gt;insert_after</a></td><td>box, value</td></tr>

<tr><td align = right>static void</td><td><a href = "#fn:<ACC>sort">&lt;ACC&gt;sort</a></td><td>box</td></tr>

<tr><td align = right>static void</td><td><a href = "#fn:<ACC>reverse">&lt;ACC&gt;reverse</a></td><td>box</td></tr>

<tr><td align = right>static int</td><td><a href = "#fn:<ACC>is_equal">&lt;ACC&gt;is_equal</a></td><td>a, b</td></tr>

<tr><td align = right>static void</td><td><a href = "#fn:<ACC>unique_merge">&lt;ACC&gt;unique_merge</a></td><td>box, merge</td></tr>

<tr><td align = right>static void</td><td><a href = "#fn:<ACC>unique">&lt;ACC&gt;unique</a></td><td>a</td></tr>

<tr><td align = right>static const char *</td><td><a href = "#fn:<SZ>to_string">&lt;SZ&gt;to_string</a></td><td>box</td></tr>

</table>

</div>

<div>

<h2><a id = "fn:" name = "fn:">Function Definitions</a></h2>

<div>

<h3><a id = "fn:<A>array" name = "fn:<A>array">&lt;A&gt;array</a></h3>

<p><code>static void <strong>&lt;A&gt;array</strong>(struct &lt;A&gt;array *const <em>a</em>)</code></p>

<p>Initialises <code>a</code> to idle.</p>

<dl>
	<dt>Order:</dt>
	<dd>&#920;(1)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<A>array_" name = "fn:<A>array_">&lt;A&gt;array_</a></h3>

<p><code>static void <strong>&lt;A&gt;array_</strong>(struct &lt;A&gt;array *const <em>a</em>)</code></p>

<p>Destroys <code>a</code> and returns it to idle.</p>

</div>

<div>

<h3><a id = "fn:<A>array_reserve" name = "fn:<A>array_reserve">&lt;A&gt;array_reserve</a></h3>

<p><code>static int <strong>&lt;A&gt;array_reserve</strong>(struct &lt;A&gt;array *const <em>a</em>, const size_t <em>min</em>)</code></p>

<p>Ensures <code>min</code> capacity of <code>a</code>. Invalidates pointers in <code>a</code>.</p>

<dl>
	<dt>Parameter: <em>min</em></dt>
	<dd>If zero, does nothing.</dd>
	<dt>Return:</dt>
	<dd>Success; otherwise, <code>errno</code> will be set.</dd>
	<dt>Exceptional return: ERANGE</dt>
	<dd>Tried allocating more then can fit in <code>size_t</code> or <code>realloc</code> doesn't follow POSIX.</dd>
	<dt>Exceptional return: realloc</dt>
</dl>

</div>

<div>

<h3><a id = "fn:<A>array_buffer" name = "fn:<A>array_buffer">&lt;A&gt;array_buffer</a></h3>

<p><code>static &lt;PA&gt;type *<strong>&lt;A&gt;array_buffer</strong>(struct &lt;A&gt;array *const <em>a</em>, const size_t <em>n</em>)</code></p>

<p>The capacity of <code>a</code> will be increased to at least <code>n</code> elements beyond the size. Invalidates any pointers in <code>a</code>.</p>

<dl>
	<dt>Return:</dt>
	<dd>The start of the buffered space at the back of the array. If <code>a</code> is idle and <code>buffer</code> is zero, a null pointer is returned, otherwise null indicates an error.</dd>
	<dt>Exceptional return: realloc, ERANGE</dt>
</dl>

</div>

<div>

<h3><a id = "fn:<A>array_insert" name = "fn:<A>array_insert">&lt;A&gt;array_insert</a></h3>

<p><code>static &lt;PA&gt;type *<strong>&lt;A&gt;array_insert</strong>(struct &lt;A&gt;array *const <em>a</em>, const size_t <em>n</em>, const size_t <em>at</em>)</code></p>

<p>Adds <code>n</code> un-initialised elements at position <code>at</code> in <code>a</code>. The buffer holds enough elements or it will invalidate any pointers in <code>a</code>.</p>

<dl>
	<dt>Parameter: <em>at</em></dt>
	<dd>A number smaller than or equal to <code>a.size</code>; if <code>a.size</code>, this function behaves as <a href = "#fn:&lt;A&gt;array_append">&lt;A&gt;array_append</a>.</dd>
	<dt>Return:</dt>
	<dd>A pointer to the start of the new region, where there are <code>n</code> elements.</dd>
	<dt>Exceptional return: realloc, ERANGE</dt>
</dl>

</div>

<div>

<h3><a id = "fn:<A>array_new" name = "fn:<A>array_new">&lt;A&gt;array_new</a></h3>

<p><code>static &lt;PA&gt;type *<strong>&lt;A&gt;array_new</strong>(struct &lt;A&gt;array *const <em>a</em>)</code></p>

<dl>
	<dt>Return:</dt>
	<dd>Adds (push back) one new element of <code>a</code>. The buffer holds an element or it will invalidate pointers in <code>a</code>.</dd>
	<dt>Exceptional return: realloc, ERANGE</dt>
	<dt>Order:</dt>
	<dd>amortised &#927;(1)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<A>array_remove" name = "fn:<A>array_remove">&lt;A&gt;array_remove</a></h3>

<p><code>static void <strong>&lt;A&gt;array_remove</strong>(struct &lt;A&gt;array *const <em>a</em>, &lt;PA&gt;type *const <em>datum</em>)</code></p>

<p>Removes <code>datum</code> from <code>a</code>.</p>

<dl>
	<dt>Order:</dt>
	<dd>&#927;(<code>a.size</code>).</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<A>array_lazy_remove" name = "fn:<A>array_lazy_remove">&lt;A&gt;array_lazy_remove</a></h3>

<p><code>static void <strong>&lt;A&gt;array_lazy_remove</strong>(struct &lt;A&gt;array *const <em>a</em>, &lt;PA&gt;type *const <em>datum</em>)</code></p>

<p>Removes <code>datum</code> from <code>a</code> and replaces it with the tail.</p>

<dl>
	<dt>Order:</dt>
	<dd>&#927;(1).</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<A>array_clear" name = "fn:<A>array_clear">&lt;A&gt;array_clear</a></h3>

<p><code>static void <strong>&lt;A&gt;array_clear</strong>(struct &lt;A&gt;array *const <em>a</em>)</code></p>

<p>Sets <code>a</code> to be empty. That is, the size of <code>a</code> will be zero, but if it was previously in an active non-idle state, it continues to be.</p>

<dl>
	<dt>Order:</dt>
	<dd>&#920;(1)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<A>array_peek" name = "fn:<A>array_peek">&lt;A&gt;array_peek</a></h3>

<p><code>static &lt;PA&gt;type *<strong>&lt;A&gt;array_peek</strong>(const struct &lt;A&gt;array *const <em>a</em>)</code></p>

<dl>
	<dt>Return:</dt>
	<dd>The last element or null if <code>a</code> is empty.</dd>
	<dt>Order:</dt>
	<dd>&#920;(1)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<A>array_pop" name = "fn:<A>array_pop">&lt;A&gt;array_pop</a></h3>

<p><code>static &lt;PA&gt;type *<strong>&lt;A&gt;array_pop</strong>(struct &lt;A&gt;array *const <em>a</em>)</code></p>

<dl>
	<dt>Return:</dt>
	<dd>Value from the the top of <code>a</code> that is removed or null if the array is empty.</dd>
	<dt>Order:</dt>
	<dd>&#920;(1)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<A>array_append" name = "fn:<A>array_append">&lt;A&gt;array_append</a></h3>

<p><code>static &lt;PA&gt;type *<strong>&lt;A&gt;array_append</strong>(struct &lt;A&gt;array *const <em>a</em>, const size_t <em>n</em>)</code></p>

<p>Adds <code>n</code> elements to the back of <code>a</code>. It will invalidate pointers in <code>a</code> if <code>n</code> is greater than the buffer space.</p>

<dl>
	<dt>Return:</dt>
	<dd>A pointer to the elements. If <code>a</code> is idle and <code>n</code> is zero, a null pointer will be returned, otherwise null indicates an error.</dd>
	<dt>Exceptional return: realloc, ERANGE</dt>
</dl>

</div>

<div>

<h3><a id = "fn:<A>array_splice" name = "fn:<A>array_splice">&lt;A&gt;array_splice</a></h3>

<p><code>static int <strong>&lt;A&gt;array_splice</strong>(struct &lt;A&gt;array *const <em>a</em>, const struct &lt;A&gt;array *const <em>b</em>, const size_t <em>i0</em>, const size_t <em>i1</em>)</code></p>

<p>Indices [<code>i0</code>, <code>i1</code>) of <code>a</code> will be replaced with a copy of <code>b</code>.</p>

<dl>
	<dt>Parameter: <em>b</em></dt>
	<dd>Can be null, which acts as empty, but cannot be <code>a</code>.</dd>
	<dt>Return:</dt>
	<dd>Success.</dd>
	<dt>Exceptional return: realloc, ERANGE</dt>
</dl>

</div>

<div>

<h3><a id = "fn:<AC>previous" name = "fn:<AC>previous">&lt;AC&gt;previous</a></h3>

<p><code>static &lt;PAC&gt;type *<strong>&lt;AC&gt;previous</strong>(const &lt;PAC&gt;box *const <em>box</em>, const &lt;PAC&gt;type *const <em>x</em>)</code></p>

<p><a href = "src/array_coda.h">src/array_coda.h</a></p>

<dl>
	<dt>Parameter: <em>x</em></dt>
	<dd>A valid entry or null to start from the last.</dd>
	<dt>Return:</dt>
	<dd>The previous valid entry from <code>box</code> (which could be null) or null if this was the first.</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<AC>next" name = "fn:<AC>next">&lt;AC&gt;next</a></h3>

<p><code>static &lt;PAC&gt;type *<strong>&lt;AC&gt;next</strong>(const &lt;PAC&gt;box *const <em>box</em>, const &lt;PAC&gt;type *const <em>x</em>)</code></p>

<p><a href = "src/array_coda.h">src/array_coda.h</a></p>

<dl>
	<dt>Parameter: <em>x</em></dt>
	<dd>A valid entry or null to start from the first.</dd>
	<dt>Return:</dt>
	<dd>The next valid entry from <code>box</code> (which could be null) or null if this was the last.</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<AC>clip" name = "fn:<AC>clip">&lt;AC&gt;clip</a></h3>

<p><code>static size_t <strong>&lt;AC&gt;clip</strong>(const &lt;PAC&gt;box *const <em>box</em>, const long <em>i</em>)</code></p>

<p><a href = "src/array_coda.h">src/array_coda.h</a></p>

<dl>
	<dt>Return:</dt>
	<dd>Converts <code>i</code> to an index in <code>box</code> from [0, <code>box.size</code>]. Negative values are wrapped.</dd>
	<dt>Order:</dt>
	<dd>&#920;(1)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<AC>copy_if" name = "fn:<AC>copy_if">&lt;AC&gt;copy_if</a></h3>

<p><code>static int <strong>&lt;AC&gt;copy_if</strong>(&lt;PAC&gt;box *const <em>a</em>, const &lt;PAC&gt;predicate_fn <em>copy</em>, const &lt;PAC&gt;box *const <em>b</em>)</code></p>

<p><a href = "src/array_coda.h">src/array_coda.h</a>: For all elements of <code>b</code>, calls <code>copy</code>, and if true, lazily copies the elements to <code>a</code>. <code>a</code> and <code>b</code> can not be the same but <code>b</code> can be null, (in which case, it does nothing.)</p>

<dl>
	<dt>Exceptional return: ERANGE, realloc</dt>
	<dt>Order:</dt>
	<dd>&#927;(<code>b.size</code> &#215; <code>copy</code>)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<AC>keep_if" name = "fn:<AC>keep_if">&lt;AC&gt;keep_if</a></h3>

<p><code>static void <strong>&lt;AC&gt;keep_if</strong>(&lt;PAC&gt;box *const <em>box</em>, const &lt;PAC&gt;predicate_fn <em>keep</em>, const &lt;PAC&gt;action_fn <em>destruct</em>)</code></p>

<p><a href = "src/array_coda.h">src/array_coda.h</a>: For all elements of <code>box</code>, calls <code>keep</code>, and if false, lazy deletes that item, calling <code>destruct</code> (if not-null).</p>

<dl>
	<dt>Order:</dt>
	<dd>&#927;(<code>a.size</code> &#215; <code>keep</code> &#215; <code>destruct</code>)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<AC>trim" name = "fn:<AC>trim">&lt;AC&gt;trim</a></h3>

<p><code>static void <strong>&lt;AC&gt;trim</strong>(&lt;PAC&gt;box *const <em>box</em>, const &lt;PAC&gt;predicate_fn <em>predicate</em>)</code></p>

<p><a href = "src/array_coda.h">src/array_coda.h</a>: Removes at either end of <code>box</code> of things that <code>predicate</code> returns true.</p>

<dl>
	<dt>Order:</dt>
	<dd>&#927;(<code>box.size</code> &#215; <code>predicate</code>)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<AC>each" name = "fn:<AC>each">&lt;AC&gt;each</a></h3>

<p><code>static void <strong>&lt;AC&gt;each</strong>(&lt;PAC&gt;box *const <em>box</em>, const &lt;PAC&gt;action_fn <em>action</em>)</code></p>

<p><a href = "src/array_coda.h">src/array_coda.h</a>: Iterates through <code>box</code> and calls <code>action</code> on all the elements. The topology of the list should not change while in this function.</p>

<dl>
	<dt>Order:</dt>
	<dd>&#927;(<code>box.size</code> &#215; <code>action</code>)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<AC>if_each" name = "fn:<AC>if_each">&lt;AC&gt;if_each</a></h3>

<p><code>static void <strong>&lt;AC&gt;if_each</strong>(&lt;PAC&gt;box *const <em>box</em>, const &lt;PAC&gt;predicate_fn <em>predicate</em>, const &lt;PAC&gt;action_fn <em>action</em>)</code></p>

<p><a href = "src/array_coda.h">src/array_coda.h</a>: Iterates through <code>box</code> and calls <code>action</code> on all the elements for which <code>predicate</code> returns true. The topology of the list should not change while in this function.</p>

<dl>
	<dt>Order:</dt>
	<dd>&#927;(<code>box.size</code> &#215; <code>predicate</code> &#215; <code>action</code>)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<AC>any" name = "fn:<AC>any">&lt;AC&gt;any</a></h3>

<p><code>static const &lt;PAC&gt;type *<strong>&lt;AC&gt;any</strong>(const &lt;PAC&gt;box *const <em>box</em>, const &lt;PAC&gt;predicate_fn <em>predicate</em>)</code></p>

<p><a href = "src/array_coda.h">src/array_coda.h</a>: Iterates through <code>box</code> and calls <code>predicate</code> until it returns true.</p>

<dl>
	<dt>Return:</dt>
	<dd>The first <code>predicate</code> that returned true, or, if the statement is false on all, null.</dd>
	<dt>Order:</dt>
	<dd>&#927;(<code>box.size</code> &#215; <code>predicate</code>)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<ACC>compare" name = "fn:<ACC>compare">&lt;ACC&gt;compare</a></h3>

<p><code>static int <strong>&lt;ACC&gt;compare</strong>(const &lt;PAC&gt;box *const <em>a</em>, const &lt;PAC&gt;box *const <em>b</em>)</code></p>

<p><a href = "src/array_coda.h">src/array_coda.h</a>: Lexicographically compares <code>a</code> to <code>b</code>. Both can be null, with null values before everything.</p>

<dl>
	<dt>Return:</dt>
	<dd><code>a &lt; b</code>: negative; <code>a == b</code>: zero; <code>a &gt; b</code>: positive.</dd>
	<dt>Order:</dt>
	<dd>&#927;(<code>a.size</code>)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<ACC>lower_bound" name = "fn:<ACC>lower_bound">&lt;ACC&gt;lower_bound</a></h3>

<p><code>static size_t <strong>&lt;ACC&gt;lower_bound</strong>(const &lt;PAC&gt;box *const <em>box</em>, const &lt;PAC&gt;type *const <em>value</em>)</code></p>

<p><a href = "src/array_coda.h">src/array_coda.h</a>: <code>box</code> should be partitioned true/false with less-then <code>value</code>.</p>

<dl>
	<dt>Return:</dt>
	<dd>The first index of <code>a</code> that is not less than <code>value</code>.</dd>
	<dt>Order:</dt>
	<dd>&#927;(log <code>a.size</code>)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<ACC>upper_bound" name = "fn:<ACC>upper_bound">&lt;ACC&gt;upper_bound</a></h3>

<p><code>static size_t <strong>&lt;ACC&gt;upper_bound</strong>(const &lt;PAC&gt;box *const <em>box</em>, const &lt;PAC&gt;type *const <em>value</em>)</code></p>

<p><a href = "src/array_coda.h">src/array_coda.h</a>: <code>box</code> should be partitioned false/true with greater-than or equal-to <a href = "#typedef:&lt;PAC&gt;type">&lt;PAC&gt;type</a> <code>value</code>.</p>

<dl>
	<dt>Return:</dt>
	<dd>The first index of <code>box</code> that is greater than <code>value</code>.</dd>
	<dt>Order:</dt>
	<dd>&#927;(log <code>a.size</code>)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<ACC>insert_after" name = "fn:<ACC>insert_after">&lt;ACC&gt;insert_after</a></h3>

<p><code>static int <strong>&lt;ACC&gt;insert_after</strong>(&lt;PAC&gt;box *const <em>box</em>, const &lt;PAC&gt;type *const <em>value</em>)</code></p>

<p><a href = "src/array_coda.h">src/array_coda.h</a>: Copies <code>value</code> at the upper bound of a sorted <code>box</code>.</p>

<dl>
	<dt>Return:</dt>
	<dd>Success.</dd>
	<dt>Exceptional return: realloc, ERANGE</dt>
	<dt>Order:</dt>
	<dd>&#927;(<code>a.size</code>)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<ACC>sort" name = "fn:<ACC>sort">&lt;ACC&gt;sort</a></h3>

<p><code>static void <strong>&lt;ACC&gt;sort</strong>(&lt;PAC&gt;box *const <em>box</em>)</code></p>

<p><a href = "src/array_coda.h">src/array_coda.h</a>: Sorts <code>box</code> by <code>qsort</code>.</p>

<dl>
	<dt>Order:</dt>
	<dd>&#927;(<code>a.size</code> \log <code>box.size</code>)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<ACC>reverse" name = "fn:<ACC>reverse">&lt;ACC&gt;reverse</a></h3>

<p><code>static void <strong>&lt;ACC&gt;reverse</strong>(&lt;PAC&gt;box *const <em>box</em>)</code></p>

<p><a href = "src/array_coda.h">src/array_coda.h</a>: Sorts <code>box</code> in reverse by <code>qsort</code>.</p>

<dl>
	<dt>Order:</dt>
	<dd>&#927;(<code>a.size</code> \log <code>a.size</code>)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<ACC>is_equal" name = "fn:<ACC>is_equal">&lt;ACC&gt;is_equal</a></h3>

<p><code>static int <strong>&lt;ACC&gt;is_equal</strong>(const &lt;PAC&gt;box *const <em>a</em>, const &lt;PAC&gt;box *const <em>b</em>)</code></p>

<p><a href = "src/array_coda.h">src/array_coda.h</a></p>

<dl>
	<dt>Return:</dt>
	<dd>If <code>a</code> piecewise equals <code>b</code>, which both can be null.</dd>
	<dt>Order:</dt>
	<dd>&#927;(<code>size</code>)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<ACC>unique_merge" name = "fn:<ACC>unique_merge">&lt;ACC&gt;unique_merge</a></h3>

<p><code>static void <strong>&lt;ACC&gt;unique_merge</strong>(&lt;PAC&gt;box *const <em>box</em>, const &lt;PAC&gt;biaction_fn <em>merge</em>)</code></p>

<p><a href = "src/array_coda.h">src/array_coda.h</a>: Removes consecutive duplicate elements in <code>box</code>.</p>

<dl>
	<dt>Parameter: <em>merge</em></dt>
	<dd>Controls surjection. Called with duplicate elements, if false <code>(x, y)-&gt;(x)</code>, if true <code>(x,y)-&gt;(y)</code>. More complex functions, <code>(x, y)-&gt;(x+y)</code> can be simulated by mixing the two in the value returned. Can be null: behaves like false.</dd>
	<dt>Order:</dt>
	<dd>&#927;(<code>a.size</code> &#215; <code>merge</code>)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<ACC>unique" name = "fn:<ACC>unique">&lt;ACC&gt;unique</a></h3>

<p><code>static void <strong>&lt;ACC&gt;unique</strong>(&lt;PAC&gt;box *const <em>a</em>)</code></p>

<p><a href = "src/array_coda.h">src/array_coda.h</a>: Removes consecutive duplicate elements in <code>a</code>.</p>

<dl>
	<dt>Order:</dt>
	<dd>&#927;(<code>a.size</code>)</dd>
</dl>

</div>

<div>

<h3><a id = "fn:<SZ>to_string" name = "fn:<SZ>to_string">&lt;SZ&gt;to_string</a></h3>

<p><code>static const char *<strong>&lt;SZ&gt;to_string</strong>(const &lt;PSZ&gt;box *const <em>box</em>)</code></p>

<p><a href = "src/to_string.h">src/to_string.h</a>: print the contents of <code>box</code> in a static string buffer of 256 bytes, with limitations of only printing 4 things at a time. <code>&lt;PSZ&gt;box</code> is contracted to be the box itself. <code>&lt;SZ&gt;</code> is loosely contracted to be a name <code>&lt;X&gt;box[&lt;X_TO_STRING_NAME&gt;]</code>.</p>

<dl>
	<dt>Return:</dt>
	<dd>Address of the static buffer.</dd>
	<dt>Order:</dt>
	<dd>&#920;(1)</dd>
</dl>

</div>

</div>

<div>

<h2><a id = "license:" name = "license:">License</a></h2>

<p>2016 Neil Edelman, distributed under the terms of the <a href = "https://opensource.org/licenses/MIT">MIT License</a>.</p>

</div>

</body>

</html>
