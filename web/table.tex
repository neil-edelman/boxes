\documentclass[12pt]{article}

% input
\bibliographystyle{ieeetr}
\usepackage[utf8]{inputenc}
%\usepackage{times} % font
\usepackage{lmodern} % scalable font
\usepackage{graphicx} % include graphics
\usepackage{amsmath} % align, nobreakdash
\usepackage[pdf,tmpdir]{graphviz} % digraph
\usepackage{fullpage} % book margins -> std margins
\usepackage{wrapfig} % wrapfigure
%\usepackage{moreverb} % verbatimtabinput
\usepackage{subcaption} % subcaptionbox
\usepackage[colorlinks]{hyperref} % pdf links
\usepackage{url} % url support
%\usepackage{comment} % comment

% code doesn't wrap
\usepackage[table]{xcolor}
\definecolor{light-gray}{gray}{0.95}
\newcommand{\code}[1]{\colorbox{light-gray}{\texttt{#1}}}

% create new commands
%\def\^#1{\textsuperscript{#1}}
%\def\!{\overline}
%\def\degree{\ensuremath{^\circ}}
\def\Scale{0.5}

% colourize titles
\definecolor{ilrblue}{RGB}{79,166,220}
\usepackage{titling}
\pretitle{\vspace{-3em}\fontfamily{\sfdefault}\fontsize{18bp}{18bp}\color{ilrblue}\selectfont}
\posttitle{\par\vspace{18bp}}
\preauthor{\normalfont\bfseries\selectfont\MakeUppercase}
\postauthor{\par\vspace{4bp}}
\predate{\normalfont\selectfont}
\postdate{\par\vspace{-8bp}}
\usepackage{titlesec}
\titleformat{\section}{\fontfamily{\sfdefault}\selectfont\normalsize\bfseries\color{ilrblue}\MakeUppercase}{\thesection}{1em}{}
\titleformat{\subsection}{\fontfamily{\sfdefault}\normalsize\bfseries\color{ilrblue}}{\thesubsection}{1em}{}
\titleformat{\subsubsection}{\fontfamily{\sfdefault}\normalsize\bfseries\color{ilrblue}\it}{\thesubsubsection}{1em}{}
% Ewww
\makeatletter
\renewenvironment{abstract}{%
    \if@twocolumn
      \section*{\abstractname}%
    \else \small %
      \begin{center}%
        {\bfseries\color{ilrblue} \abstractname\vspace{\z@}\vspace{-12bp}}%
      \end{center}%
      \quotation
    \fi}
    {\if@twocolumn\else\endquotation\fi}
\makeatother

% for hyperref
\hypersetup{
  linkcolor=ilrblue, % internal (figure) links
  urlcolor=ilrblue,
  filecolor=ilrblue,
  citecolor=ilrblue, % bibliography links
  pdfauthor={\@author},
  pdftitle={\@title},
  pdfsubject={\@title},
  pdfpagemode=UseNone
}

\author{Neil A. Edelman}
\title{Engineering a hash-table where allocation is expensive}
\date{2022-02-22}

\begin{document}

\maketitle

\abstract{Imbuing a hash-table entry with a `next index' allows collisions to be stored in a stack of open entries grown from the unused. Storing a present bit in the `next' instead of the key allows the key to be unconstrained. In practice, this scheme simplifies load-factor-based expansions, and often saves a dereference step.}

\section{Introduction}

By `expensive' we mean (mostly) usability.

Separate chaining as seen in Figure~\ref{chaining}. As pictured here, this poses a problem: one can only be in one hash-table at a time; any subclasses must inherit from the node, not the data. In practice, one would have another dereference between the link in the linked-list and the data. With ordered data, keeping a self-balancing tree cuts down the worst case to $\mathcal{O}(\log n)$\cite{knuth1998sorting}. However, it is damaging to cache-coherence; the large number of objects can be, at least, difficult to keep track. It allows unconstrained load factors, which is useful in some cases.

Read the Art.

Open addressing. Robin Hood, obviously.\cite{wiki?} One can calculate the displacement from the hash, but we have to have a way of telling if it's null; one could have the maximum value of displaced be a flag. More cache-coherent for simple values. Less expected value of lookup. Exhibits clustering. Must maintain a low load factor, (already we can see a lot of clustering.) Reliance on randomness of hash function? ``Open addressing can lead to more concise tables with better cache performance than bucketing, but performance will be more brittle as the load factor (ratio of occupancy to capacity) of the hash table starts to get high.''\cite{skiena2008algorithm}

The data structure is similar to that of coalesced hashing\cite{williams1959handling}, except we need no extra buckets; coalescing cannot occur because the stack and the closed entries are orthogonal.

It is homomorphic to separate-chaining in the regime where the load factor is equal-to or less-then one. It may be more cache-friendly than separate chaining.

The distinction between open and closed, is then, every bucket with contents begins with a closed entry, followed by zero-or-more open entries 

%\begin{wrapfigure}{r}{0.5\textwidth} %[!ht]
\begin{figure}
	\centering
	\digraph[scale=\Scale]{star}{
	rankdir=LR;
	graph [truecolor=true, bgcolor=transparent];
	fontface=modern;
	node [shape=box, style=filled, fillcolor="Gray95"];
	hash [label=<<TABLE BORDER="0">
	<TR><TD COLSPAN="3" ALIGN="LEFT"><FONT COLOR="Gray85">&lt;star&gt;table: char *</FONT></TD></TR>
	<TR>
		<TD>&nbsp;</TD>
		<TD BORDER="0" ALIGN="RIGHT" BGCOLOR="Gray90">load factor</TD>
		<TD BORDER="0" ALIGN="RIGHT" BGCOLOR="Gray90">12/16</TD>
	</TR>
	<TR>
		<TD>&nbsp;</TD>
		<TD BORDER="0" ALIGN="RIGHT">E[no bucket]</TD>
		<TD BORDER="0" ALIGN="RIGHT">1.33(0.7)</TD>
	</TR>
	<TR>
		<TD>&nbsp;</TD>
		<TD BORDER="0" ALIGN="RIGHT" BGCOLOR="Gray90">max bucket</TD>
		<TD BORDER="0" ALIGN="RIGHT" BGCOLOR="Gray90">3</TD>
	</TR>
	<TR>
		<TD BORDER="0"><FONT FACE="Times-Italic">i</FONT></TD>
		<TD BORDER="0"><FONT FACE="Times-Bold">hash</FONT></TD>
		<TD BORDER="0"><FONT FACE="Times-Bold">key</FONT></TD>
		<TD BORDER="0"><FONT FACE="Times-Bold">next</FONT></TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x0</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT">0x1</TD>
		<TD ALIGN="RIGHT">0x91</TD>
		<TD ALIGN="LEFT">Castor</TD>
		<TD PORT="1">\detokenize{⬤}</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x2</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT">0x3</TD>
		<TD ALIGN="RIGHT">0x3</TD>
		<TD ALIGN="LEFT">Deneb</TD>
		<TD PORT="3">\detokenize{⬤}</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x4</TD>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x44</TD>
		<TD ALIGN="LEFT" BGCOLOR="Gray90">Sirius</TD>
		<TD PORT="4" BGCOLOR="Gray90">\detokenize{⬤}</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT">0x5</TD>
		<TD ALIGN="RIGHT">0x35</TD>
		<TD ALIGN="LEFT">Spica</TD>
		<TD PORT="5">\detokenize{⬤}</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x6</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT">0x7</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x8</TD>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0xd8</TD>
		<TD ALIGN="LEFT" BGCOLOR="Gray90">Rigel</TD>
		<TD PORT="8" BGCOLOR="Gray90">\detokenize{⬤}</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT">0x9</TD>
		<TD ALIGN="RIGHT">0xe9</TD>
		<TD ALIGN="LEFT">Pollux</TD>
		<TD PORT="9">\detokenize{⬤}</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0xa</TD>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x4a</TD>
		<TD ALIGN="LEFT" BGCOLOR="Gray90">Betelgeuse</TD>
		<TD PORT="10" BGCOLOR="Gray90">\detokenize{⬤}</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BORDER="2">0xb</TD>
		<TD ALIGN="RIGHT">0x4f</TD>
		<TD ALIGN="LEFT">Procyon</TD>
		<TD PORT="11">\detokenize{◯}</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0xc</TD>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0xec</TD>
		<TD ALIGN="LEFT" BGCOLOR="Gray90">Regulus</TD>
		<TD PORT="12" BGCOLOR="Gray90">\detokenize{⬤}</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT">0xd</TD>
		<TD ALIGN="RIGHT">0x33</TD>
		<TD ALIGN="LEFT">Antares</TD>
		<TD PORT="13">\detokenize{◯}</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0xe</TD>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0xb3</TD>
		<TD ALIGN="LEFT" BGCOLOR="Gray90">Sol</TD>
		<TD PORT="14" BGCOLOR="Gray90">\detokenize{◯}</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT">0xf</TD>
		<TD ALIGN="RIGHT">0x9f</TD>
		<TD ALIGN="LEFT">Polaris</TD>
		<TD PORT="15">\detokenize{⬤}</TD>
	</TR>
</TABLE>>];
	node [shape=plain, fillcolor=none]
	e13 [label="0xd"];
	hash:3 -> e13 [tailclip=false];
	e14 [label="0xe"];
	e13 -> e14;
	i0xe [label="0xe", fontcolor="Gray"];
	hash:13 -> i0xe [color="Gray"];
	e11 [label="0xb"];
	hash:15 -> e11 [tailclip=false];
	}
	\caption{Hash map.\label{star} Order of insertion is Sol, Sirius, Rigel, Procyon, Betelgeuse, Antares, Spica, Deneb, Regulus, Castor, Polaris. Load factor 11/16 = 0.69. Expected value of number of queries 1.36(0.7).}
%0: Sol -> 0.000000
%1: Sirius -> 8.600000
%8: Rigel -> 860.000000
%9: Procyon -> 11.000000
%11: Betelgeuse -> 700.000000
%16: Antares -> 550.000000
%17: Spica -> 250.000000
%20: Deneb -> 2615.000000
%22: Regulus -> 79.000000
%25: Castor -> 52.000000
%49: Polaris -> 430.000000
\end{figure}

\section{Implementation}



\subsection{Next}

In order to offer a complete range of data for the key, (specifically, not just a pointer,) the nullity is stored in the `next' field. There are two special values that must be differentiated: there is no closed value associated with this address, called `NULL', and there is no next value, called `END'. In the implementation, this is parameterized by a single type to store indices.

These two special values cause the indexing to be two values short. Since the implementation is a power-of-two, it causes the addressable space to be one-bit less; half the size, or the equivalent of a signed positive integer. The bits `NULL' and `END' were chosen to minimize average power requirements while leaving a natural $[0, 011..11]$ for addressing. That is, $100..00$, and $100..01$. In Figure~\ref{star}, where there (unusually) are 8~bits, the addressable space is $[0, 127]$, and `NULL', `END' are 128, 129.

\subsection{Orthogonal Features}

Among the set of  Most-recently-used first

Consistent hashing.

\subsection{Structure in Memory}

\subsection{Machine Considerations}

\subsection{Running Time}

\subsection{Limits}

\bibliography{table}

\end{document}
