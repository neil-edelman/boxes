\documentclass[12pt]{article}

% input
\bibliographystyle{ieeetr}
\usepackage[utf8]{inputenc}
%\usepackage{times} % font
\usepackage{lmodern} % scalable font
\usepackage[pdftex]{graphicx} % include graphics
\usepackage{amsmath} % align, nobreakdash
\usepackage[pdf,tmpdir]{graphviz} % digraph
\usepackage{fullpage} % book margins -> std margins
\usepackage{wrapfig} % wrapfigure
%\usepackage{moreverb} % verbatimtabinput
\usepackage{subcaption} % subcaptionbox
\usepackage[colorlinks]{hyperref} % pdf links
\usepackage{url} % url support
%\usepackage{comment} % comment
\usepackage{xfrac}
\usepackage[table]{xcolor}

\usepackage{siunitx}
%\usepackage{graphicx} already
\usepackage{latexsym}
\usepackage{keyval}
\usepackage{ifthen}
\usepackage{moreverb}
\usepackage[siunitx, subfolder]{gnuplottex}

% https://tex.stackexchange.com/questions/259247/rescaling-gnuplottex-to-fit-in-subfigure
%\usepackage{epstopdf}
%\usepackage{printlen}
%\usepackage[utf8]{inputenx}
%\usepackage{xparse}
%\ExplSyntaxOn
%\DeclareExpandableDocumentCommand{\convertlen}{ O{cm} m }
% {
%  \dim_to_unit:nn { #2 } { 1 #1 } cm
% }
%\ExplSyntaxOff
% fuck it, just guess

\newcommand{\code}[1]{\colorbox{light-gray}{\texttt{#1}}}
\def\Scale{0.5}

% colourize titles
\definecolor{light-gray}{gray}{0.95}
\definecolor{ilrblue}{RGB}{79,166,220}
\usepackage{titling}
\pretitle{\vspace{-3em}\fontfamily{\sfdefault}\fontsize{18bp}{18bp}\color{ilrblue}\selectfont}
\posttitle{\par\vspace{18bp}}
\preauthor{\normalfont\bfseries\selectfont\MakeUppercase}
\postauthor{\par\vspace{4bp}}
\predate{\normalfont\selectfont}
\postdate{\par\vspace{-8bp}}
\usepackage{titlesec}
\titleformat{\section}{\fontfamily{\sfdefault}\selectfont\normalsize\bfseries\color{ilrblue}\MakeUppercase}{\thesection}{1em}{}
\titleformat{\subsection}{\fontfamily{\sfdefault}\normalsize\bfseries\color{ilrblue}}{\thesubsection}{1em}{}
\titleformat{\subsubsection}{\fontfamily{\sfdefault}\normalsize\bfseries\color{ilrblue}\it}{\thesubsubsection}{1em}{}
\makeatletter
\renewenvironment{abstract}{%
    \if@twocolumn
      \section*{\abstractname}%
    \else \small %
      \begin{center}%
        {\bfseries\color{ilrblue} \abstractname\vspace{\z@}\vspace{-6bp}}%
      \end{center}%
      \quotation
    \fi}
    {\if@twocolumn\else\endquotation\fi}
\makeatother

% for hyperref
\hypersetup{
  linkcolor=ilrblue, % internal (figure) links
  urlcolor=ilrblue,
  filecolor=ilrblue,
  citecolor=ilrblue, % bibliography links
  pdfauthor={\@author},
  pdftitle={\@title},
  pdfsubject={\@title},
  pdfpagemode=UseNone
}

\author{Neil A. Edelman}
\title{Allocation-conscious chained hash-table}
\date{2022-02-22}

\begin{document}

\maketitle

\abstract{A bucket scheme where overlapping each entry with an index to the next entry gives us an inline-chained hash-table. The front entry in the bucket is closed, and all others are open, taken from unoccupied slots. This design can often be less expensive, performance-wise and to maintain. Having a chained hash-table with the simplicity of allocation of open-addressing is especially attractive for low-level languages, devices, and data.}

\section{Introduction}

Performance is a critical issue, but we are also concerned with usability. Specifically, without higher-level language support for native hash-tables or automatic garbage-collection, we want to easily understand and maintain a general hash-table, with minimal surprise on behalf of the users.

Overlapping each entry with an index to the next entry creates a hash-table that is self-contained in memory, yet behaves as a chained hash in the regime where the load factor is less-then one.\cite{knuth1998sorting} We call this inline-chaining to differentiate it from separate-chaining, where the buckets are objects with links between them.

This data structure is similar to that of coalesced-hashing\cite{williams1959handling}, but coalescing cannot occur. The closed entries that form the heads of buckets and the open entries that form a stack are orthogonal.

\section{Example Comparison}

%\begin{wrapfigure}{r}{0.5\textwidth} %[!ht]
\begin{figure}
	\centering
	\subcaptionbox{Separate-chaining.\label{types:separate}}{%
		\digraph[scale=\Scale]{separate}{
	rankdir=LR;
	graph [truecolor=true, bgcolor=transparent];
	fontface=modern;
	node [shape=box, style=filled, fillcolor="Gray95"];
	hash [label=<<TABLE BORDER="0">
	<TR>
		<TD BORDER="0"><FONT FACE="Times-Italic">i</FONT></TD>
		<TD BORDER="0"><FONT FACE="Times-Bold">next</FONT></TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x0</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT">0x1</TD>
		<TD PORT="1">\detokenize{⬤}</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x2</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT">0x3</TD>
		<TD PORT="3">\detokenize{⬤}</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x4</TD>
		<TD PORT="4" BGCOLOR="Gray90">\detokenize{⬤}</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT">0x5</TD>
		<TD PORT="5">\detokenize{⬤}</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x6</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT">0x7</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x8</TD>
		<TD PORT="8" BGCOLOR="Gray90">\detokenize{⬤}</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT">0x9</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0xa</TD>
		<TD PORT="10" BGCOLOR="Gray90">\detokenize{⬤}</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BORDER="0">0xb</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0xc</TD>
		<TD PORT="12" BGCOLOR="Gray90">\detokenize{⬤}</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT">0xd</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0xe</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT">0xf</TD>
		<TD PORT="15">\detokenize{⬤}</TD>
	</TR>
</TABLE>>];
	e1 [label=<<TABLE BORDER="0">
	<TR>
		<TD ALIGN="RIGHT">0x91</TD>
		<TD ALIGN="LEFT">Castor</TD>
		<TD ALIGN="RIGHT">52</TD>
		<TD PORT="1">\detokenize{⬤}</TD>
	</TR>
</TABLE>>];
	e3 [label=<<TABLE BORDER="0">
	<TR>
		<TD ALIGN="RIGHT">0x3</TD>
		<TD ALIGN="LEFT">Deneb</TD>
		<TD ALIGN="RIGHT">2615</TD>
		<TD PORT="3">\detokenize{⬤}</TD>
	</TR>
</TABLE>>];
	e4 [label=<<TABLE BORDER="0">
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x44</TD>
		<TD ALIGN="LEFT" BGCOLOR="Gray90">Sirius</TD>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">8.6</TD>
		<TD PORT="4" BGCOLOR="Gray90">\detokenize{⬤}</TD>
	</TR>
</TABLE>>];
	e5 [label=<<TABLE BORDER="0">
	<TR>
		<TD ALIGN="RIGHT">0x35</TD>
		<TD ALIGN="LEFT">Spica</TD>
		<TD ALIGN="RIGHT">250</TD>
		<TD PORT="5">\detokenize{⬤}</TD>
	</TR>
</TABLE>>];
	e8 [label=<<TABLE BORDER="0">
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0xd8</TD>
		<TD ALIGN="LEFT" BGCOLOR="Gray90">Rigel</TD>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">860</TD>
		<TD PORT="8" BGCOLOR="Gray90">\detokenize{⬤}</TD>
	</TR>
</TABLE>>];
	e10 [label=<<TABLE BORDER="0">
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x4a</TD>
		<TD ALIGN="LEFT" BGCOLOR="Gray90">Betelgeuse</TD>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">700</TD>
		<TD PORT="10" BGCOLOR="Gray90">\detokenize{⬤}</TD>
	</TR>
</TABLE>>];
	e11 [label=<<TABLE BORDER="0">
	<TR>
		<TD ALIGN="RIGHT">0x4f</TD>
		<TD ALIGN="LEFT">Procyon</TD>
		<TD ALIGN="RIGHT">11</TD>
		<TD PORT="11">\detokenize{◯}</TD>
	</TR>
</TABLE>>];
	e12 [label=<<TABLE BORDER="0">
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0xec</TD>
		<TD ALIGN="LEFT" BGCOLOR="Gray90">Regulus</TD>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">79</TD>
		<TD PORT="12" BGCOLOR="Gray90">\detokenize{⬤}</TD>
	</TR>
</TABLE>>];
	e13 [label=<<TABLE BORDER="0">
	<TR>
		<TD ALIGN="RIGHT">0x33</TD>
		<TD ALIGN="LEFT">Antares</TD>
		<TD ALIGN="RIGHT">550</TD>
		<TD PORT="13">\detokenize{◯}</TD>
	</TR>
</TABLE>>];
	e14 [label=<<TABLE BORDER="0">
	<TR>
		<TD ALIGN="RIGHT">0xb3</TD>
		<TD ALIGN="LEFT">Sol</TD>
		<TD ALIGN="RIGHT">0</TD>
		<TD PORT="14">\detokenize{◯}</TD>
	</TR>
</TABLE>>];
	e15 [label=<<TABLE BORDER="0">
	<TR>
		<TD ALIGN="RIGHT">0x9f</TD>
		<TD ALIGN="LEFT">Polaris</TD>
		<TD ALIGN="RIGHT">430</TD>
		<TD PORT="15">\detokenize{⬤}</TD>
	</TR>
</TABLE>>];
	node [shape=plain, fillcolor=none, headclip = false, tailclip=false]
	hash:1 -> e1;
	hash:3 -> e3 -> e13 -> e14;
	hash:4 -> e4;
	hash:5 -> e5;
	hash:8 -> e8;
	hash:10 -> e10;
	hash:12 -> e12;
	hash:15 -> e15;
	e15 -> e11;
		}
	}
	\subcaptionbox{Open-addressing.\label{types:open}}{%
		\digraph[scale=\Scale]{open}{
	rankdir=LR;
	graph [truecolor=true, bgcolor=transparent];
	fontface=modern;
	node [shape=box, style=filled, fillcolor="Gray95"];
	hash [label=<<TABLE BORDER="0">
	<TR>
		<TD BORDER="0"><FONT FACE="Times-Italic">i</FONT></TD>
		<TD BORDER="0"><FONT FACE="Times-Italic">disp.</FONT></TD>
		<TD BORDER="0"><FONT FACE="Times-Bold">hash</FONT></TD>
		<TD BORDER="0"><FONT FACE="Times-Bold">key</FONT></TD>
		<TD BORDER="0"><FONT FACE="Times-Bold">value</FONT></TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x0</TD>
		<TD BGCOLOR="Gray90">1</TD>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x4f</TD>
		<TD ALIGN="LEFT" BGCOLOR="Gray90">Procyon</TD>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">11</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT">0x1</TD>
		<TD>0</TD>
		<TD ALIGN="RIGHT">0x91</TD>
		<TD ALIGN="LEFT">Castor</TD>
		<TD ALIGN="RIGHT">52</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x2</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT">0x3</TD>
		<TD>0</TD>
		<TD ALIGN="RIGHT">0x3</TD>
		<TD ALIGN="LEFT">Deneb</TD>
		<TD ALIGN="RIGHT">2615</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x4</TD>
		<TD BGCOLOR="Gray90">1</TD>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x33</TD>
		<TD ALIGN="LEFT" BGCOLOR="Gray90">Antares</TD>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">550</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT">0x5</TD>
		<TD PORT="14">2</TD>
		<TD ALIGN="RIGHT">0xb3</TD>
		<TD ALIGN="LEFT">Sol</TD>
		<TD ALIGN="RIGHT">0</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x6</TD>
		<TD BGCOLOR="Gray90">2</TD>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x44</TD>
		<TD ALIGN="LEFT" BGCOLOR="Gray90">Sirius</TD>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">8.6</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT">0x7</TD>
		<TD>2</TD>
		<TD ALIGN="RIGHT">0x35</TD>
		<TD ALIGN="LEFT">Spica</TD>
		<TD ALIGN="RIGHT">250</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x8</TD>
		<TD PORT="8" BGCOLOR="Gray90">0</TD>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0xd8</TD>
		<TD ALIGN="LEFT" BGCOLOR="Gray90">Rigel</TD>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">860</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT">0x9</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0xa</TD>
		<TD PORT="10" BGCOLOR="Gray90">0</TD>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x4a</TD>
		<TD ALIGN="LEFT" BGCOLOR="Gray90">Betelgeuse</TD>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">700</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT">0xb</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0xc</TD>
		<TD PORT="12" BGCOLOR="Gray90">0</TD>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0xec</TD>
		<TD ALIGN="LEFT" BGCOLOR="Gray90">Regulus</TD>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">79</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT">0xd</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0xe</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT">0xf</TD>
		<TD PORT="15">0</TD>
		<TD ALIGN="RIGHT">0x9f</TD>
		<TD ALIGN="LEFT">Polaris</TD>
		<TD ALIGN="RIGHT">430</TD>
	</TR>
</TABLE>>];
	node [shape=plain, fillcolor=none]
		}
	}
	\subcaptionbox{Inline-chaining.\label{types:inline}}{%
		\digraph[scale=\Scale]{inline}{
	rankdir=LR;
	graph [truecolor=true, bgcolor=transparent];
	fontface=modern;
	node [shape=box, style=filled, fillcolor="Gray95"];
	hash [label=<<TABLE BORDER="0">
	<TR>
		<TD BORDER="0"><FONT FACE="Times-Italic">i</FONT></TD>
		<TD BORDER="0"><FONT FACE="Times-Bold">hash</FONT></TD>
		<TD BORDER="0"><FONT FACE="Times-Bold">key</FONT></TD>
		<TD BORDER="0"><FONT FACE="Times-Bold">value</FONT></TD>
		<TD BORDER="0"><FONT FACE="Times-Bold">next</FONT></TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x0</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT">0x1</TD>
		<TD ALIGN="RIGHT">0x91</TD>
		<TD ALIGN="LEFT">Castor</TD>
		<TD ALIGN="RIGHT">52</TD>
		<TD PORT="1">\detokenize{⬤}</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x2</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT">0x3</TD>
		<TD ALIGN="RIGHT">0x3</TD>
		<TD ALIGN="LEFT">Deneb</TD>
		<TD ALIGN="RIGHT">2615</TD>
		<TD PORT="3">\detokenize{⬤}</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x4</TD>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x44</TD>
		<TD ALIGN="LEFT" BGCOLOR="Gray90">Sirius</TD>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">8.6</TD>
		<TD PORT="4" BGCOLOR="Gray90">\detokenize{⬤}</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT">0x5</TD>
		<TD ALIGN="RIGHT">0x35</TD>
		<TD ALIGN="LEFT">Spica</TD>
		<TD ALIGN="RIGHT">250</TD>
		<TD PORT="5">\detokenize{⬤}</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x6</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT">0x7</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x8</TD>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0xd8</TD>
		<TD ALIGN="LEFT" BGCOLOR="Gray90">Rigel</TD>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">860</TD>
		<TD PORT="8" BGCOLOR="Gray90">\detokenize{⬤}</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT">0x9</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0xa</TD>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0x4a</TD>
		<TD ALIGN="LEFT" BGCOLOR="Gray90">Betelgeuse</TD>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">700</TD>
		<TD PORT="10" BGCOLOR="Gray90">\detokenize{⬤}</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BORDER="2">0xb</TD>
		<TD ALIGN="RIGHT">0x4f</TD>
		<TD ALIGN="LEFT">Procyon</TD>
		<TD ALIGN="RIGHT">11</TD>
		<TD PORT="11">\detokenize{◯}</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0xc</TD>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0xec</TD>
		<TD ALIGN="LEFT" BGCOLOR="Gray90">Regulus</TD>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">79</TD>
		<TD PORT="12" BGCOLOR="Gray90">\detokenize{⬤}</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT">0xd</TD>
		<TD ALIGN="RIGHT">0x33</TD>
		<TD ALIGN="LEFT">Antares</TD>
		<TD ALIGN="RIGHT">550</TD>
		<TD PORT="13">\detokenize{◯}</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0xe</TD>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0xb3</TD>
		<TD ALIGN="LEFT" BGCOLOR="Gray90">Sol</TD>
		<TD ALIGN="RIGHT" BGCOLOR="Gray90">0</TD>
		<TD PORT="14" BGCOLOR="Gray90">\detokenize{◯}</TD>
	</TR>
	<TR>
		<TD ALIGN="RIGHT">0xf</TD>
		<TD ALIGN="RIGHT">0x9f</TD>
		<TD ALIGN="LEFT">Polaris</TD>
		<TD ALIGN="RIGHT">430</TD>
		<TD PORT="15">\detokenize{⬤}</TD>
	</TR>
</TABLE>>];
	node [shape=plain, fillcolor=none]
	e13 [label="0xd"];
	hash:3 -> e13 [tailclip=false];
	e14 [label="0xe"];
	e13 -> e14;
	i0xe [label="0xe", fontcolor="Gray"];
	hash:13 -> i0xe [color="Gray"];
	e11 [label="0xb"];
	hash:15 -> e11 [tailclip=false];
		}
	}
	\caption{A map from some star names to light-year distance using different collision-resolution schemes. Load factor \sfrac{11}{16} = 0.69. Expected value: number of queries chained, 1.4(7),
%1.36(0.7),
and probe-sequence in open-addressing, 1.6(9),
%1.60(0.9),
(sample standard deviation.)\label{types}
Order of insertion: Sol, Sirius, Rigel, Procyon, Betelgeuse, Antares, Spica, Deneb, Regulus, Castor, Polaris.}
\end{figure}

Figure~\ref{types} shows a comparison of some standard hash-table types. It uses D.J.~Bernstein's {\it djb2} to hash a string to 8-bit unsigned integer. All tables use a most-recently-used heuristic as probe-order; experimentally, this was found to make little difference in the run-time, and is advantageous when the access pattern is non-uniform\cite{brent1973reducing, sleator1985self}.

Separate-chaining is seen in Figure~\ref{types:separate}; this is more like T.D. Hanson's {\it uthash}: only being in one hash-table at a time. A similar hash to {\it C++}'s {\it std::unordered\_map}, {\it Lua}'s {\it table}, and many others, would have another dereference between the linked-list and the entry. This style of hash-table allows unconstrained load factors. With ordered data, keeping a self-balancing tree cuts down the worst case to $\mathcal{O}(\log n)$\cite{knuth1998sorting}, as in {\it Java}. The expected number of dereferences is a constant added to the number of queries.

Open-addressing\cite{peterson1957addressing} as seen in Figure~\ref{types:open}, is another, more compact, and generally more cache-coherent table design. Robin Hood hashing\cite{celis1985robin} has been used to keep the variation in the query length to a minimum; here, with the condition on whether to evict strengthened because of the most-recently-used heuristic. It has lower maximum load-factor, because clustering decreases performance as the load-factor reaches saturation\cite{skiena2008algorithm}; so, although they have less data {\it per} entry, they have on average more entries. Practically, 0.69 is high; {\it Python}\cite{knuth1998sorting} uses a maximum of \sfrac{2}{3}. One can calculate the displacement from the hash, but we have to have a general way of telling if it's null. The lack of symmetry presents a difficulty removing entries.

Inline-chaining, as seen in Figure~\ref{types:inline}, is, in many ways, a hybrid between the two. The dark circles represent the closed heads, and the outline the open stack, with a highlight to indicate the stack position. The expected number of dereferences is number of queries for plain-old-data. Because of the {\it next index} field, the space taken is one index {\it per} entry more then open-addressing. Being chained offers a higher load-factor, but it is not possible to exceed one.

\section{Results}

\subsection{Running Time}

Because the closed and open entries are orthogonal for inline-chaining, the limiting factor in the worst-case is the same as for separate-chaining, and it will have identical behaviour. In the average case, we do at least as much work by a constant factor; in addition to the steps required for chaining, we also have to sometimes also have to manage the stack. Moving the top of the stack involves finding the closed head of the top entry and iterating until the top. However, modification requires only copying one entry; we aren't concerned with the order of the stack, only the order of the next indices.

\begin{figure}%
\centering%
\begin{gnuplot}[terminal=cairolatex, terminaloptions={color dashed pdf size 6.2,3.4}]
set style line 1 lt 5 lw 2 lc rgb '#0072bd' pointtype 1 pointsize 0.5
set style line 2 lt 5 lw 2 lc rgb '#ff0000' pointtype 2 pointsize 0.5
set style line 3 lt 5 lw 2 lc rgb '#00ac33' pointtype 5 pointsize 0.5
set style line 4 lt 5 lw 2 lc rgb '#19d3f5' pointtype 5 pointsize 0.5
set grid
set xlabel "iterations"
set ylabel "time per iteration, $t$ (ns)"
set yrange [0:2000]
set log x
set format x '\tiny %g'
set format y '\tiny %g'
#set tics font "Modern, 8" #rotate by 20 right # ineffectual
plot \
"../timing/graph/closed.tsv" using 1:($2/$1*1000):($3/$1*1000) with errorlines title "closed" ls 1, \
"../timing/graph/open.tsv" using 1:($2/$1*1000):($3/$1*1000) with errorlines title "open" ls 2, \
"../timing/graph/unordered.tsv" using 1:($2/$1*1000):($3/$1*1000) with errorlines title "unordered set" ls 3
\end{gnuplot}
\caption{This is a simple example using the cairolatex-terminal.}%
\label{pic:cairolatex}%
\end{figure}%

\section{Implementation}

\subsection{Next Entry}

The `next' field in inline-chaining does take space, but offers a convenient place to store out-of-band information. This offers a complete range of data for the key, (specifically, not just a pointer, it could be an integer zero.) There are two special values that must be differentiated: there is no closed value associated with this address, called `NULL', and there is no next value in the bucket, called `END'.

Since the implementation uses power-of-two resizes, it causes the addressable space to be one-bit less; half the size, or the equivalent of a signed positive integer. The bits `NULL' and `END' were chosen to minimize average power requirements while leaving a natural $[0, 011..11]$ for addressing. That is, $100..00$, and $100..01$. In Figure~\ref{types:inline}, where there are 8~bits, the addressable space is $[0, 127]$, and `NULL', `END' are 128, 129.

\subsection{Load Factor}

It is possible to get rid of load factor calculations by making the maximum load factor identically one. Only if the hash-table is full does one resize. In an inline-chained hash-table, the entries and the next index are overlapped; this means that the capacity for each goes up in the same allocation.

\subsection{Power-of-Two}

Consistent hashing.\cite{karger1997consistent}

/* Initialize new values. Mask to identify the added bits. */
	/* Rehash most closed buckets in the lower half. Create waiting
	 linked-stack by borrowing next. */
	/* Search waiting stack for buckets that moved concurrently. */
	/* Rebuild the top stack at the high numbers from the waiting at low. */

\subsection{Stack}

Lazy stack; hysteresis.
static void PN(forcestack)(struct N(table) *const table);
static void PN(shrinkstack)(struct N(table) *const table,
	const PN(uint) b);
static void PN(movetotop)(struct N(table) *const table, const PN(uint) m);

\subsection{Maintaining Orthogonality}

We must move them around. Still O(n), but the average is twice that. Doesn't make much difference experimentally.

\subsection{Inverse Hash Function}

``Defining `TABLE\_INVERSE` says <typedef:<PN>hash\_fn> forms a bijection
 between the range in <typedef:<PN>key> and the image in <typedef:<PN>uint>.
 The keys are not stored in the hash table, but they are generated from the
 hashes using this inverse-mapping.'' otherwise ``Equivalence relation between <typedef:<PN>key> that satisfies
 `<PN>is\_equal\_fn(a, b) -> <PN>hash(a) == <PN>hash(b)`. Not used if
 `TABLE\_INVERSE` because the comparison is done in hash space, in that case.''

\subsection{Iteration}

For implementations that do not provide a special iteration mechanism, iteration on separate-chaining is $\mathcal{O}(\text{capacity} + \text{size})$. For open-addressing and inline-chaining, because we store collisions in the hash-table itself, it's $\mathcal{O}(\text{capacity})$. However, a practical capacity in open-addressing will be larger because the decrease in performance as the load-factor reaches saturation.

\section{Conclusion}

\bibliography{table}

\end{document}
