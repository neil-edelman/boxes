A Practical Implementation of Tries as an Index
B-tree Prefix Trees as an Index
===

** Abstract Data Type **

This is a set on a variable-length key, always terminated by a sentinel (allow a string is a prefix of another string in the same trie). It is ordered, and permits range queries with a prefix.

For proper ordering, most-significant bit first; prefix strings the sentinel should be less-than the encoding of all the characters. In practice, a null-terminated string. A Modified~UTF-8 example is Figure~\ref{prefix:bits}. It stores the keys in lexicographic order, but not by any collation algorithm.

\fig{prefix:bits} terminator, like in that paper; a terminator will . This terminator should have less-than all the other characters for ordering, so by a _string_ we mean _a null-terminated string_. ; for example, in Modified UTF-8, `Z < a < z < Ã¢`. <show a picture>

** Implementation **

An implementation is an associative-array Patrica trie \cite{}: binary, storing only bit differences; Figure~\ref{prefix:logic}.

This is an index: unlike a binary search where the key is retrieved and compared, we have the string decision bit in the key that cuts down the size of the search space. When we get a prefix match, only one string needs to be retrieved to check that it's a match with all the bits that we skipped over.

** Tree Structure **

non-empty complete binary tree

semi-implicit: lose the ability to go up the tree; have to have the size \ref{prefix:mem}

** Machine Considerations **

The data has been engineered for maximum effectiveness of the cache in reading and traversing. That is, the tree structure and the string decisions have been reduced to each a byte and placed at the the top of the data structure of the tree. The size of this sub-structure should be a multiple of the cache line size, while also maximizing the dynamic range allowed for each byte; a trie (also a B-tree) of order 256 is an obvious choice.

instead of adding in one big trie, where the data type presents a limit of how big it is, we have pointers to sub-blocks. This is seen in ... This allows us to shrink the data-type significantly; for a non-empty complete binary tree that has `n` leaves (order `n`), it has `n - 1` the internal nodes, or branches. The maximum that the left branch count can be is when the right node of the root is a leaf, that is `n - 2`. If we set this left-branch maximum to the maximum of the data type, we can use all the range. Practically, we set it to 254 instead of 255; the branches take up 255, and the branch size number is 1, for alignment.

** Limits **

Worst-case `{ a, aa, aaa, aaaa, ... }`. The case where the trie has strings that are bounded, as the tree grows, we can guarantee . . .

This is valid, `{ dictate, dictator }`, as well as, `{ dictator, dictionary, dictionaries }`, but, as outlined, one ca'n't put `{ dictionary, dictionaries }`: it is too long a skip value. There are several modifications that would allow this, but they are out of this scope.

Insertion: Any leaf on the sub-tree queried will do; in this implementation, favours the left side.

on split, do we have to go locally and see if we can join them?
